

# These "empty" enums (they must have at least one element) will be replaced at runtime with
# definitions based on database tables.

enum ConditionsMeasurementSource { DUMMY }
enum SeeingTrend { DUMMY }
enum ConditionsExpectationType { DUMMY }
enum FilterType { DUMMY }
enum ProposalStatus { DUMMY }

"""Email address, matching ^\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,3}$"""
scalar EmailAddress

"AtomEvent creation parameters."
input AddAtomEventInput {
  atomId: AtomId!
  atomStage: AtomStage!
}

"The result of adding a atom event."
type AddAtomEventResult {

  "The new atom event that was added."
  event: AtomEvent!

}

"DatasetEvent creation parameters."
input AddDatasetEventInput {

  "Dataset id"
  datasetId: DatasetId!

  "Dataset execution stage."
  datasetStage: DatasetStage!

}

"The result of adding a dataset event."
type AddDatasetEventResult {

  "The new dataset event that was added."
  event: DatasetEvent!

}

input AddProgramUserInput {
  orcidId:     String!
  programId:   ProgramId!
  role:        ProgramUserRole!
  SET:         ProgramUserPropertiesInput
}

type AddProgramUserResult {
  programUser: ProgramUser!
}

"SequenceEvent creation parameters."
input AddSequenceEventInput {
  visitId: VisitId!
  command: SequenceCommand!
}

"The result of adding a sequence event."
type AddSequenceEventResult {

  "The new sequence event that was added."
  event: SequenceEvent!

}

"SlewEvent creation parameters."
input AddSlewEventInput {
  visitId:   VisitId!
  slewStage: SlewStage!
}

"The result of adding a slew event."
type AddSlewEventResult {

  "The new slew event that was added."
  event: SlewEvent!

}

"StepEvent creation parameters."
input AddStepEventInput {
  stepId: StepId!
  stepStage: StepStage!
}

"The result of adding a step event."
type AddStepEventResult {

  "The new step event that was added."
  event: StepEvent!

}

"""
Input to the 'addTimeChargeCorrection' mutation. Identifies the visit
that will be corrected and describes the correction itself.
"""
input AddTimeChargeCorrectionInput {
  visitId:     VisitId!
  correction:  TimeChargeCorrectionInput!
}

"""
The result of the 'addTimeChargeCorrection' mutation.  It contains the
visit's updated TimeChargeInvoice after applying the correction.
"""
type AddTimeChargeCorrectionResult {
  timeChargeInvoice: TimeChargeInvoice!
}

"""
Air mass range creation and edit parameters
"""
input AirMassRangeInput {
  min: PosBigDecimal
  max: PosBigDecimal
}

"""
An individual time allocation.
"""
type Allocation {
  category:    TimeAccountingCategory!
  scienceBand: ScienceBand!
  duration:    TimeSpan!
}

"""
An individual time allocation input.
"""
input AllocationInput {
  category:    TimeAccountingCategory!
  scienceBand: ScienceBand!
  duration:    TimeSpanInput!
}

"""
Create an angle from a signed value.  Choose exactly one of the available units.
"""
input AngleInput {
  microarcseconds: Long
  microseconds: BigDecimal
  milliarcseconds: BigDecimal
  milliseconds: BigDecimal
  arcseconds: BigDecimal
  seconds: BigDecimal
  arcminutes: BigDecimal
  minutes: BigDecimal
  degrees: BigDecimal
  hours: BigDecimal
  dms: String
  hms: String
}

"""
Atom-level events.  The execution of a single atom will generate multiple events.
"""
type AtomEvent implements ExecutionEvent {

  "Event id"
  id: ExecutionEventId!

  "Visit associated with this event."
  visit: Visit!

  "Observation whose execution produced this event."
  observation: Observation!

  "Time at which this event was received"
  received: Timestamp!

  "Event type."
  eventType: ExecutionEventType!

  "Atom associated with this event."
  atom: AtomRecord!

  "Atom execution stage."
  atomStage: AtomStage!

}

enum AtomExecutionState {

  "No events have been received since the atom was recorded."
  NOT_STARTED

  "Events have been received, but no 'EndAtom'."
  ONGOING

  "An event with an 'END_ATOM' 'AtomStage' was received."
  COMPLETED

  "An ongoing atom was abandoned."
  ABANDONED

}

"""
AtomId id formatted as `a-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`
"""
scalar AtomId

"Execution stage or phase of an individual atom"
enum AtomStage {

  END_ATOM

  START_ATOM

}


"An atom as recorded by Observe."
type AtomRecord {

  "Atom ID."
  id: AtomId!

  "The instrument associated with this atom."
  instrument: Instrument!

  "Visit in which this atom was executed."
  visit: Visit!

  "Created by Observe at this time."
  created: Timestamp!

  """
  The execution state of this atom, according to events received (if any) from
  Observe.
  """
  executionState: AtomExecutionState!

  "Time interval during which this atom executed."
  interval: TimestampInterval

  "Sequence type."
  sequenceType: SequenceType!

  "Recorded steps associated with this atom."
  steps(

    """
    Starts the result set at (or after if not existent) the given step creation
    time.
    """
    OFFSET: Timestamp

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt

  ): StepRecordSelectResult!

  "Atom ID from the generated atom, if any, that produced this atom record."
  generatedId: AtomId

}

"AtomRecord query results, limited to a maximum of 1000 entries."
type AtomRecordSelectResult {

  "Matching atom records up to the return size limit of 1000."
  matches: [AtomRecord!]!

  "`true` when there were additional matches that were not returned."
  hasMore: Boolean!

}

"""
CategorizedTime grouped with a ScienceBand.  A program may contain multiple
observations in distinct bands.  Time accounting at the program level must
distinguish time spent in observations of each of these bands.
"""
type BandedTime {

  "ScienceBand associated with the time, if any."
  band: ScienceBand

  "Time distributed across the program, partner, and non-charged categories."
  time: CategorizedTime!

}

"""
Create or edit a band brightness value with integrated magnitude units.  When creating a new value, all fields except "error" are required.
"""
input BandBrightnessIntegratedInput {
  band: Band!

  """
  The value field is required when creating a new instance of BandBrightnessIntegrated, but optional when editing
  """
  value: BigDecimal

  """
  The units field is required when creating a new instance of BandBrightnessIntegrated, but optional when editing
  """
  units: BrightnessIntegratedUnits

  """
  Error values are optional
  """
  error: BigDecimal
}

"""
Create or edit a band brightness value with surface magnitude units.  When creating a new value, all fields except "error" are required.
"""
input BandBrightnessSurfaceInput {
  band: Band!

  """
  The value field is required when creating a new instance of BandBrightnessSurface, but optional when editing
  """
  value: BigDecimal

  """
  The units field is required when creating a new instance of BandBrightnessSurface, but optional when editing
  """
  units: BrightnessSurfaceUnits

  """
  Error values are optional
  """
  error: BigDecimal
}

"""
Create or edit a band normalized value with integrated magnitude units.  Specify at least "brightnesses" when creating a new BandNormalizedIntegrated.
"""
input BandNormalizedIntegratedInput {
  """
  The sed field is optional and nullable
  """
  sed: UnnormalizedSedInput

  """
  The brightnesses field is required when creating a new instance of BandNormalizedIntegrated, but optional when editing
  """
  brightnesses: [BandBrightnessIntegratedInput!]
}

"""
Create or edit a band normalized value with surface magnitude units.  Specify at least "brightnesses" when creating a new BandNormalizedSurface.
"""
input BandNormalizedSurfaceInput {
  """
  The sed field is optional and nullable
  """
  sed: UnnormalizedSedInput

  """
  The brightnesses field is required when creating a new instance of BandNormalizedSurface, but optional when editing
  """
  brightnesses: [BandBrightnessSurfaceInput!]
}

"""
Bias calibration step
"""
type Bias implements StepConfig {
  """
  Step type
  """
  stepType: StepType!
}

"""
Stopping point in a series of steps
"""
enum Breakpoint {
  """
  Breakpoint Enabled
  """
  ENABLED

  """
  Breakpoint Disabled
  """
  DISABLED
}

"""
A single Call for Proposals definition.
"""
type CallForProposals {

  """
  The unique Call for Proposals id associated with this Call.
  """
  id: CallForProposalsId!

  "The title of this Call for Proposals."
  title: NonEmptyString!

  """
  Describes which type of proposals are being accepted.
  """
  type: CallForProposalsType!

  """
  The semester associated with the Call.  Some types may have multiple Calls
  per semester.
  """
  semester: Semester!

  """
  Coordinate limits for targets that may be observed in this Call for Proposals.
  """
  coordinateLimits: SiteCoordinateLimits!

  """
  The active period during which accepted observations for this call may be
  observed.
  """
  active: DateInterval!

  """
  The submission deadline to use for any partners without an explicit partner
  deadline.
  """
  submissionDeadlineDefault: Timestamp

  """
  Partners that may participate in this Call.
  """
  partners: [CallForProposalsPartner!]!

  """
  Whether this Call allows PIs without a partner to participate.
  """
  allowsNonPartnerPi: Boolean!

  """
  The submission deadline for non-partner PIs, when allowed to participate.
  """
  nonPartnerDeadline: Timestamp

  """
  When specified, the observations executed in this Call will only use these
  instruments.  When not specified, all otherwise available instruments may be
  used.
  """
  instruments: [Instrument!]!

  """
  Default proprietary period to use for propograms linked to this Call.
  """
  proprietaryMonths: NonNegInt!

  """
  Whether this Call is PRESENT or has been DELETED.
  """
  existence: Existence!
}

"""
Defines a unique ID for each Call for Proposals.
"""
scalar CallForProposalsId

"""
The properties of a Call for Proposal in an input for creation and editing.
"""
input CallForProposalsPropertiesInput {

  "Type of the call. Required on create."
  type: CallForProposalsType

  "Semester associated with the call. Required on create."
  semester: Semester

  """
  Coordinate limits.  If not specified, they will default according to the
  coordinates that are safely visible during the active period of the call.
  """
  coordinateLimits: SiteCoordinateLimitsInput

  """
  Active period start date (inclusive) for this call.  The date is considered to
  be the local date at each observation site.  Observations may begin the
  evening of the indicated date at the site of the observation.

  The start date is required on create and must be before the `activeEnd` date.
  Not nullable.  Limited to dates between 1900 and 2100 (exclusive).
  """
  activeStart: Date

  """
  Active period end date (exclusive) for this call.  The date is considered to
  be the local date at each observation site.  Observations may end the
  morning of the indicated date at the site of the observation.

  The end date is required on create and must be after the `activeStart` date.
  Not nullable.  Limited to dates between 1900 and 2100 (exclusive).
  """
  activeEnd: Date

  """
  Specifies a submission deadline to use for any partners without an explicit
  partner deadline.
  """
  submissionDeadlineDefault: Timestamp

  """
  Partners that may participate in the call along with their respective
  deadlines.  When editing, supply the entire list of all partners. Defaults to
  all partners.
  """
  partners: [CallForProposalsPartnerInput!]

  """
  When specified, the call is limited to the listed instruments.  When not
  specified, all otherwise available instruments may be used.  When editing,
  supply the entire list of instruments to set.  Nullable on edit.
  """
  instruments: [Instrument!]

  """
  The default proprietary period for proposals linked to this call.  If not
  specified, the default period for the call type will be used.
  """
  proprietaryMonths: NonNegInt

  "DELETED or PRESENT.  On create defaults to PRESENT."
  existence: Existence
}

"""
Coordinate limits input per site.
"""
input SiteCoordinateLimitsInput {

  north: CoordinateLimitsInput

  south: CoordinateLimitsInput

}

input CoordinateLimitsInput {

  """
  Optional RA limit start RA.
  """
  raStart: RightAscensionInput

  """
  Optional RA limit end RA.
  """
  raEnd: RightAscensionInput

  """
  Optional declination limit start declination.
  """
  decStart: DeclinationInput

  """
  Optional declination limit end declination.
  """
  decEnd: DeclinationInput

}

"""
Groups a partner with its submission deadline.
"""
type CallForProposalsPartner {
  partner:  Partner!

  """
  Sets the submission deadline for this partner, overriding the
  'submissionDeadlineDefault' for the Call for Proposals.
  """
  submissionDeadlineOverride: Timestamp

  """
  The submission deadline for this partner.  This will be the
  'submissionDeadlineOverride' if specified, but otherwise the
  'submissionDeadlineDefault' of the Call for Proposals itself.
  """
  submissionDeadline: Timestamp
}

input CallForProposalsPartnerInput {
  partner:  Partner!

  """
  If this partner has an explicit submission deadline that overrides the
  Call for Proposals 'defaultSubmissionDeadine' then it is specified here.
  Otherwise, the partner deadline is the default deadline for the call.
  """
  submissionDeadlineOverride: Timestamp
}

type CallsForProposalsSelectResult {
  matches: [CallForProposals!]!
  hasMore: Boolean!
}

enum CallForProposalsType {
  DEMO_SCIENCE
  DIRECTORS_TIME
  FAST_TURNAROUND
  LARGE_PROGRAM
  POOR_WEATHER
  REGULAR_SEMESTER
  SYSTEM_VERIFICATION
}

"""
Catalog id consisting of catalog name, string identifier and an optional object type
"""
input CatalogInfoInput {
  """
  The name field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  name: CatalogName

  """
  The id field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  id: NonEmptyString

  """
  The objectType field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  objectType: NonEmptyString
}

"A time amount broken into charge class categories."
type CategorizedTime {

  "Time charged to the program / PI."
  program: TimeSpan!

  "Time charged to the partner."
  partner: TimeSpan!

  "Execution time that is not charged."
  nonCharged: TimeSpan!

  "Total of program, partner and uncharged times."
  total: TimeSpan!

}

"""
A minimum to maximum categorized time estimate.  The actual execution time
should vary between the two extremes, depending upon which observations and
groups are ultimately completed.
"""
type CategorizedTimeRange {

   """Minimum remaining time estimate."""
   minimum: CategorizedTime!

   """Maximum remaining time estimate."""
   maximum: CategorizedTime!
}

"""
Describes an observation clone operation, making any edits in the `SET`
parameter.  The observation status in the cloned observation defaults to NEW.
Identify the observation to clone by specifying either its id or reference.  If
both are specified, they must refer to the same observation.  If neither is
specified, nothing will be cloned.
"""
input CloneObservationInput {
  observationId:        ObservationId
  observationReference: ObservationReferenceLabel
  SET:                  ObservationPropertiesInput
}

"""
The result of cloning an observation, containing the original and new observations.
"""
type CloneObservationResult {
  """
  The original unmodified observation which was cloned.
  """
  originalObservation: Observation!

  """
  The new cloned (but possibly modified) observation.
  """
  newObservation: Observation!
}

"""
Describes a target clone operation, making any edits in the `SET` parameter and replacing the target in the selected `REPLACE_IN` observations
"""
input CloneTargetInput {
  targetId: TargetId!
  SET: TargetPropertiesInput
  REPLACE_IN: [ObservationId!]
}

"""
The result of cloning a target, containing the original and new targets.
"""
type CloneTargetResult {
  """
  The original unmodified target which was cloned
  """
  originalTarget: Target!

  """
  The new cloned (but possibly modified) target
  """
  newTarget: Target!
}

"""
Constraint set creation and editing parameters
"""
input ConstraintSetInput {
  """
  The imageQuality field is required when creating a new instance of ConstraintSet, but optional when editing
  """
  imageQuality: ImageQuality

  """
  The cloudExtinction field is required when creating a new instance of ConstraintSet, but optional when editing
  """
  cloudExtinction: CloudExtinction

  """
  The skyBackground field is required when creating a new instance of ConstraintSet, but optional when editing
  """
  skyBackground: SkyBackground

  """
  The waterVapor field is required when creating a new instance of ConstraintSet, but optional when editing
  """
  waterVapor: WaterVapor

  """
  The elevationRange field is required when creating a new instance of ConstraintSet, but optional when editing
  """
  elevationRange: ElevationRangeInput
}

scalar ChronicleId
scalar TransactionId

interface ChronicleEntry {
  id: ChronicleId!
  transactionId: TransactionId!
  user: User
  timestamp: Timestamp!
}

type ConditionsEntry { # implements ChronicleEntry
  id: ChronicleId!
  transactionId: TransactionId!
  user: User
  timestamp: Timestamp!
  measurement: ConditionsMeasurement
  intuition: ConditionsIntuition
}

input ConditionsEntryInput {
  measurement: ConditionsMeasurementInput
  intuition: ConditionsIntuitionInput
}

"Non-negative floating-point value."
scalar Extinction

type ConditionsMeasurement {
  source:     ConditionsMeasurementSource!
  seeing:     Angle
  extinction: Extinction
  wavelength: Wavelength
  azimuth:    Angle
  elevation:  Angle
}

input ConditionsMeasurementInput {
  source:     ConditionsMeasurementSource!
  seeing:     AngleInput
  extinction: Extinction
  wavelength: WavelengthInput
  azimuth:    AngleInput
  elevation:  AngleInput
}

type ConditionsIntuition {
  expectation: ConditionsExpectation
  seeingTrend: SeeingTrend
}

input ConditionsIntuitionInput {
  expectation: ConditionsExpectationInput
  seeingTrend: SeeingTrend
}

type ConditionsExpectation {
  type: ConditionsExpectationType!
  timeframe: TimeSpan!
}

input ConditionsExpectationInput {
  type: ConditionsExpectationType!
  timeframe: TimeSpanInput!
}

type AddConditionsEntryResult {
  conditionsEntry: ConditionsEntry!
}

"""
RA/Dec limits.
"""
type CoordinateLimits {

  """
  The start limit defines the beginning (inclusive) of an RA range in which
  observations will be accepted.
  """
  raStart: RightAscension!

  """
  The end limit defines the end (inclusive) of an RA range in which observations
  will be accepted.
  """
  raEnd: RightAscension!

  """
  The start limit defines the beginning (inclusive) of a declination range in
  which observations will be accepted.
  """
  decStart: Declination!

  """
  The end limit defines the end (inclusive) of a declination range in which
  observations will be accepted.
  """
  decEnd: Declination!

}

"""
Absolute coordinates relative base epoch
"""
input CoordinatesInput {
  ra: RightAscensionInput
  dec: DeclinationInput
}

input CreateCallForProposalsInput {
  SET: CallForProposalsPropertiesInput
}

type CreateCallForProposalsResult {
  callForProposals: CallForProposals!
}

"""
Observation creation parameters.  One of programId or programReference is
required.  If both are provided, they must refer to the same program.
"""
input CreateObservationInput {
  programId: ProgramId
  proposalReference: ProposalReferenceLabel
  programReference: ProgramReferenceLabel
  SET: ObservationPropertiesInput
}

"""
The result of creating a new observation.
"""
type CreateObservationResult {
  """
  The newly created observation.
  """
  observation: Observation!
}

"""
Program creation parameters
"""
input CreateProgramInput {
  SET: ProgramPropertiesInput
}

"""
The result of creating a new program.
"""
type CreateProgramResult {
  """
  The newly created program.
  """
  program: Program!
}

"""
Input for creating a proposal.
"""
input CreateProposalInput {
  programId:         ProgramId!
  SET:               ProposalPropertiesInput!
}

"""
The result of creating new proposal
"""
type CreateProposalResult {
  """
  The newly created proposal.
  """
  proposal: Proposal!
}

"""
Target creation parameters.  One of programId or programReference is required.
If both are provided, they must refer to the same program.
"""
input CreateTargetInput {
  programId: ProgramId
  proposalReference: ProposalReferenceLabel
  programReference: ProgramReferenceLabel
  SET: TargetPropertiesInput!
}

"""
The result of creating a new target.
"""
type CreateTargetResult {
  """
  The newly created target.
  """
  target: Target!
}

"""
Dark calibration step
"""
type Dark implements StepConfig {
  """
  Step type
  """
  stepType: StepType!
}

"""
Editable dataset properties
"""
input DatasetPropertiesInput {
  qaState: DatasetQaState,
  comment: NonEmptyString
}

"""
Date in ISO-8601 representation in format YYYY-MM-DD (e.g., '2024-07-31').
"""
scalar Date

"""
Date interval marked by a start 'Date' (inclusive) and an end 'Date' (exclusive).
Dates are interpreted as local dates.
"""
type DateInterval {

  "Start date, local to the observation site, of the interval (inclusive)."
  start: Date!

  "End date, local to the observation site, of the interval (exclusive)."
  end: Date!

}

"""
Declination, choose one of the available units
"""
input DeclinationInput {
  microarcseconds: Long
  degrees: BigDecimal
  dms: DmsString
}

"Input for deleting a proposal."
input DeleteProposalInput {
  programId: ProgramId!
}

"The result of deleting a proposal."
type DeleteProposalResult {
  "`true` if a proposal was deleted, `false` otherwise."
  result: Boolean!
}

"""
Add or delete targets in an asterism
"""
input EditAsterismsPatchInput {
  ADD:    [TargetId!]
  DELETE: [TargetId!]
}

"""
Type of edit that triggered an event
"""
enum EditType {
  """
  EditType Created
  """
  CREATED

  """
  EditType Updated
  """
  UPDATED

  """
  EditType Deleted. Used for hard deletion of calibrations
  """
  DELETED_CAL
}

"""
Elevation range creation and edit parameters.  Choose one of airMass or hourAngle constraints.
"""
input ElevationRangeInput {
  airMass: AirMassRangeInput
  hourAngle: HourAngleRangeInput
}

type Email {
  "Sender email address"
  senderEmail: EmailAddress!

  "Recipient email address"
  recipientEmail: EmailAddress!

  "Email subject"
  subject: NonEmptyString!

  "Text format message"
  textMessage: NonEmptyString!

  "Html format message"
  htmlMessage: NonEmptyString

  "Original time of the email sending attempt"
  originalTime: Timestamp!

  "The status of the email"
  status: EmailStatus!

  "The time of the last status update"
  statusTime: Timestamp!
}

enum EmailStatus {
  "Mail provider has queued the message"
  QUEUED

  "Mail provider has rejected the message"
  REJECTED

  "Mail provider has accepted the message"
  ACCEPTED

  "The message has been accepted by the recipient email server"
  DELIVERED

  "The message is not deliverable"
  PERMANENT_FAILURE

  "The message could not be delivered, but may be deliverable later"
  TEMPORARY_FAILURE
}

"""
Create or edit an emission line with integrated line flux units.  When creating a new value, all fields are required.
"""
input EmissionLineIntegratedInput {
  wavelength: WavelengthInput!

  """
  The lineWidth field is required when creating a new instance of EmissionLineIntegrated, but optional when editing
  """
  lineWidth: PosBigDecimal

  """
  The lineFlux field is required when creating a new instance of EmissionLineIntegrated, but optional when editing
  """
  lineFlux: LineFluxIntegratedInput
}

"""
Create or edit an emission line with surface line flux units.  When creating a new value, all fields are required.
"""
input EmissionLineSurfaceInput {
  wavelength: WavelengthInput!

  """
  The lineWidth field is required when creating a new instance of EmissionLineSurface, but optional when editing
  """
  lineWidth: PosBigDecimal

  """
  The lineFlux field is required when creating a new instance of EmissionLineSurface, but optional when editing
  """
  lineFlux: LineFluxSurfaceInput
}

"""
Create or edit emission lines with integrated line flux and flux density continuum units. Both "lines" and "fluxDensityContinuum" are required when creating a new EmissionLinesIntegrated.
"""
input EmissionLinesIntegratedInput {
  """
  The lines field is required when creating a new instance of EmissionLinesIntegrated, but optional when editing
  """
  lines: [EmissionLineIntegratedInput!]

  """
  The fluxDensityContinuum field is required when creating a new instance of EmissionLinesIntegrated, but optional when editing
  """
  fluxDensityContinuum: FluxDensityContinuumIntegratedInput
}

"""
Create or edit emission lines with surface line flux and flux density continuum units. Both "lines" and "fluxDensityContinuum" are required when creating a new EmissionLinesSurface.
"""
input EmissionLinesSurfaceInput {
  """
  The lines field is required when creating a new instance of EmissionLinesSurface, but optional when editing
  """
  lines: [EmissionLineSurfaceInput!]

  """
  The fluxDensityContinuum field is required when creating a new instance of EmissionLinesSurface, but optional when editing
  """
  fluxDensityContinuum: FluxDensityContinuumSurfaceInput
}

"Execution event types."
enum ExecutionEventType {
  "Sequence-level event type."
  SEQUENCE

  "Slew event type."
  SLEW

  "Atom-level event type."
  ATOM

  "Step-level event type."
  STEP

  "Dataset-level event type."
  DATASET
}

"""
Exposure time mode input.  Specify fixed or signal to noise, but not both
"""
input ExposureTimeModeInput {
  """
  The signalToNoise field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  signalToNoise: SignalToNoiseModeInput

  """
  The fixedExposure field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  fixedExposure: FixedExposureModeInput
}

"""
Fixed exposure time mode parameters
"""
input FixedExposureModeInput {
  """
  exposure count
  """
  count: NonNegInt!

  """
  exposure time
  """
  time: TimeSpanInput!
}

"""
Flux density entry
"""
input FluxDensity {
  wavelength: WavelengthInput!
  density: PosBigDecimal!
}

"""
A flux density continuum value with integrated units
"""
input FluxDensityContinuumIntegratedInput {
  value: PosBigDecimal!
  units: FluxDensityContinuumIntegratedUnits!
  error: PosBigDecimal
}

"""
A flux density continuum value with surface units
"""
input FluxDensityContinuumSurfaceInput {
  value: PosBigDecimal!
  units: FluxDensityContinuumSurfaceUnits!
  error: PosBigDecimal
}

"""
Create or edit a gaussian source.  Specify both "fwhm" and "spectralDefinition" when creating a new Gaussian.
"""
input GaussianInput {
  """
  The fwhm field is required when creating a new instance of Gaussian, but optional when editing
  """
  fwhm: AngleInput

  """
  The spectralDefinition field is required when creating a new instance of Gaussian, but optional when editing
  """
  spectralDefinition: SpectralDefinitionIntegratedInput
}

"""
GCAL calibration step (flat / arc)
"""
type Gcal implements StepConfig {
  """
  GCAL continuum, present if no arcs are used
  """
  continuum: GcalContinuum

  """
  GCAL arcs, one or more present if no continuum is used
  """
  arcs: [GcalArc!]!

  """
  GCAL filter
  """
  filter: GcalFilter!

  """
  GCAL diffuser
  """
  diffuser: GcalDiffuser!

  """
  GCAL shutter
  """
  shutter: GcalShutter!

  """
  Step type
  """
  stepType: StepType!
}

"""
GCAL arc
"""
enum GcalArc {
  """
  GcalArc ArArc
  """
  AR_ARC

  """
  GcalArc ThArArc
  """
  TH_AR_ARC

  """
  GcalArc CuArArc
  """
  CU_AR_ARC

  """
  GcalArc XeArc
  """
  XE_ARC
}

"""
GCAL continuum
"""
enum GcalContinuum {
  """
  GcalContinuum IrGreyBodyLow
  """
  IR_GREY_BODY_LOW

  """
  GcalContinuum IrGreyBodyHigh
  """
  IR_GREY_BODY_HIGH

  """
  GcalContinuum QuartzHalogen 5W
  """
  QUARTZ_HALOGEN5

  """
  GcalContinuum QuartzHalogen 100W
  """
  QUARTZ_HALOGEN100
}

"""
GCAL diffuser
"""
enum GcalDiffuser {
  """
  GcalDiffuser Ir
  """
  IR

  """
  GcalDiffuser Visible
  """
  VISIBLE
}

"""
GCAL filter
"""
enum GcalFilter {
  """
  GcalFilter None
  """
  NONE

  """
  GcalFilter Gmos
  """
  GMOS

  """
  GcalFilter Hros
  """
  HROS

  """
  GcalFilter Nir
  """
  NIR

  """
  GcalFilter Nd10
  """
  ND10

  """
  GcalFilter Nd16
  """
  ND16

  """
  GcalFilter Nd20
  """
  ND20

  """
  GcalFilter Nd30
  """
  ND30

  """
  GcalFilter Nd40
  """
  ND40

  """
  GcalFilter Nd45
  """
  ND45

  """
  GcalFilter Nd50
  """
  ND50
}

"""
GCAL shutter
"""
enum GcalShutter {
  """
  GcalShutter Open
  """
  OPEN

  """
  GcalShutter Closed
  """
  CLOSED
}

"""
GMOS amp count
"""
enum GmosAmpCount {
  """
  GmosAmpCount Three
  """
  THREE

  """
  GmosAmpCount Six
  """
  SIX

  """
  GmosAmpCount Twelve
  """
  TWELVE
}

"""
CCD Readout Configuration
"""
type GmosCcdMode {
  """
  GMOS X-binning
  """
  xBin: GmosXBinning!

  """
  GMOS Y-binning
  """
  yBin: GmosYBinning!

  """
  GMOS Amp Count
  """
  ampCount: GmosAmpCount!

  """
  GMOS Amp Gain
  """
  ampGain: GmosAmpGain!

  """
  GMOS Amp Read Mode
  """
  ampReadMode: GmosAmpReadMode!
}

"""
GMOS CCD readout input parameters
"""
input GmosCcdModeInput {

  """
  X Binning, defaults to 'ONE'.
  """
  xBin: GmosXBinning

  """
  Y Binning, defaults to 'ONE'.
  """
  yBin: GmosYBinning

  """
  Amp Count, defaults to 'TWELVE'.
  """
  ampCount: GmosAmpCount

  """
  Amp Gain, defaults to 'LOW'
  """
  ampGain: GmosAmpGain

  """
  Amp Read Mode, defaults to 'SLOW'
  """
  ampReadMode: GmosAmpReadMode

}

"""
GMOS Custom Mask
"""
type GmosCustomMask {
  """
  Custom Mask Filename
  """
  filename: String!

  """
  Custom Slit Width
  """
  slitWidth: GmosCustomSlitWidth!
}

"""
GMOS custom mask input parameters
"""
input GmosCustomMaskInput {
  """
  Custom mask file name
  """
  filename: String!

  """
  Custom mask slit width
  """
  slitWidth: GmosCustomSlitWidth!
}

"""
GMOS Custom Slit Width
"""
enum GmosCustomSlitWidth {
  """
  GmosCustomSlitWidth CustomWidth_0_25
  """
  CUSTOM_WIDTH_0_25

  """
  GmosCustomSlitWidth CustomWidth_0_50
  """
  CUSTOM_WIDTH_0_50

  """
  GmosCustomSlitWidth CustomWidth_0_75
  """
  CUSTOM_WIDTH_0_75

  """
  GmosCustomSlitWidth CustomWidth_1_00
  """
  CUSTOM_WIDTH_1_00

  """
  GmosCustomSlitWidth CustomWidth_1_50
  """
  CUSTOM_WIDTH_1_50

  """
  GmosCustomSlitWidth CustomWidth_2_00
  """
  CUSTOM_WIDTH_2_00

  """
  GmosCustomSlitWidth CustomWidth_5_00
  """
  CUSTOM_WIDTH_5_00
}

"""
GMOS Detector Translation X Offset
"""
enum GmosDtax {
  """
  GmosDtax MinusSix
  """
  MINUS_SIX

  """
  GmosDtax MinusFive
  """
  MINUS_FIVE

  """
  GmosDtax MinusFour
  """
  MINUS_FOUR

  """
  GmosDtax MinusThree
  """
  MINUS_THREE

  """
  GmosDtax MinusTwo
  """
  MINUS_TWO

  """
  GmosDtax MinusOne
  """
  MINUS_ONE

  """
  GmosDtax Zero
  """
  ZERO

  """
  GmosDtax One
  """
  ONE

  """
  GmosDtax Two
  """
  TWO

  """
  GmosDtax Three
  """
  THREE

  """
  GmosDtax Four
  """
  FOUR

  """
  GmosDtax Five
  """
  FIVE

  """
  GmosDtax Six
  """
  SIX
}

"""
Electronic offsetting
"""
enum GmosEOffsetting {
  """
  GmosEOffsetting On
  """
  ON

  """
  GmosEOffsetting Off
  """
  OFF
}

"""
GMOS grating order
"""
enum GmosGratingOrder {
  """
  GmosGratingOrder Zero
  """
  ZERO

  """
  GmosGratingOrder One
  """
  ONE

  """
  GmosGratingOrder Two
  """
  TWO
}

type GmosNodAndShuffle {
  """
  Offset position A
  """
  posA: Offset!

  """
  Offset position B
  """
  posB: Offset!

  """
  Whether to use electronic offsetting
  """
  eOffset: GmosEOffsetting!

  """
  Shuffle offset
  """
  shuffleOffset: Int!

  """
  Shuffle cycles
  """
  shuffleCycles: Int!
}

"""
Creation input parameters for GMOS nod and shuffle
"""
input GmosNodAndShuffleInput {

  """
  Offset position A
  """
  posA: OffsetInput!

  """
  Offset position B
  """
  posB: OffsetInput!

  """
  Electronic offsetting
  """
  eOffset: GmosEOffsetting!

  """
  Shuffle offset
  """
  shuffleOffset: PosInt!

  """
  Shuffle cycles
  """
  shuffleCycles: PosInt!
}

"""
GmosNorth atom, a collection of steps that should be executed in their entirety
"""
type GmosNorthAtom {
  """
  Atom id
  """
  id: AtomId!

  """
  Optional description of the atom.
  """
  description: String

  """
  Observe class for this atom as a whole (combined observe class for each of
  its steps).
  """
  observeClass: ObserveClass!

  """
  Individual steps that comprise the atom
  """
  steps: [GmosNorthStep!]!

}

"""
GmosNorth Detector type
"""
enum GmosNorthDetector {
  E2_V

  HAMAMATSU
}

"""
GMOS North dynamic step configuration
"""
type GmosNorthDynamic {
  """
  GMOS exposure time
  """
  exposure: TimeSpan!

  """
  GMOS CCD Readout
  """
  readout: GmosCcdMode!

  """
  GMOS detector x offset
  """
  dtax: GmosDtax!

  """
  GMOS region of interest
  """
  roi: GmosRoi!

  """
  GMOS North grating
  """
  gratingConfig: GmosNorthGratingConfig

  """
  GMOS North filter
  """
  filter: GmosNorthFilter

  """
  GMOS North FPU
  """
  fpu: GmosNorthFpu
}

"""
GMOS North instrument configuration input
"""
input GmosNorthDynamicInput {
  """
  Exposure time
  """
  exposure: TimeSpanInput!

  """
  GMOS CCD readout
  """
  readout: GmosCcdModeInput!

  """
  GMOS detector x offset
  """
  dtax: GmosDtax!

  """
  GMOS region of interest
  """
  roi: GmosRoi!

  """
  GMOS North grating
  """
  gratingConfig: GmosNorthGratingConfigInput

  """
  GMOS North filter
  """
  filter: GmosNorthFilter

  """
  GMOS North FPU
  """
  fpu: GmosNorthFpuInput
}

"""
GMOS North Execution Config
"""
type GmosNorthExecutionConfig {
  """
  GMOS North static configuration
  """
  static: GmosNorthStatic!

  """
  GMOS North acquisition execution sequence.  Pass `true` to (re)start
  acquisition from the initial step.
  """
  acquisition(reset: Boolean = false): GmosNorthExecutionSequence

  """
  GMOS North science execution
  """
  science: GmosNorthExecutionSequence
}

"""
Next atom to execute and potential future atoms.
"""
type GmosNorthExecutionSequence {

  """
  Next atom to execute.
  """
  nextAtom: GmosNorthAtom!

  """
  (Prefix of the) remaining atoms to execute, if any.
  """
  possibleFuture: [GmosNorthAtom!]!

  """
  Whether there are more anticipated atoms than those that appear in
  'possibleFuture'.
  """
  hasMore: Boolean!

}

"""
GMOS North FPU option, either builtin or custom mask
"""
type GmosNorthFpu {
  """
  The custom mask, if in use
  """
  customMask: GmosCustomMask

  """
  GMOS North builtin FPU, if in use
  """
  builtin: GmosNorthBuiltinFpu
}

"""
GMOS North FPU input parameters (choose custom or builtin).
"""
input GmosNorthFpuInput {
  """
  Custom mask FPU option
  """
  customMask: GmosCustomMaskInput

  """
  Builtin FPU option
  """
  builtin: GmosNorthBuiltinFpu
}

"""
GMOS North Grating Configuration
"""
type GmosNorthGratingConfig {
  """
  GMOS North Grating
  """
  grating: GmosNorthGrating!

  """
  GMOS grating order
  """
  order: GmosGratingOrder!

  """
  Grating wavelength
  """
  wavelength: Wavelength!
}

"""
GMOS North grating input parameters
"""
input GmosNorthGratingConfigInput {
  """
  GmosGmosNorth grating
  """
  grating: GmosNorthGrating!

  """
  GMOS grating order
  """
  order: GmosGratingOrder!

  """
  Grating wavelength
  """
  wavelength: WavelengthInput!
}

"""
Edit or create GMOS North Long Slit advanced configuration
"""
input GmosNorthLongSlitInput {

  """
  The grating field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  grating: GmosNorthGrating

  """
  The filter field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  filter: GmosNorthFilter

  """
  The fpu field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  fpu: GmosNorthBuiltinFpu

  """
  The centralWavelength field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  centralWavelength: WavelengthInput

  """
  The explicitXBin field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitXBin: GmosXBinning

  """
  The explicitYBin field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitYBin: GmosYBinning

  """
  The explicitAmpReadMode field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitAmpReadMode: GmosAmpReadMode

  """
  The explicitAmpGain field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitAmpGain: GmosAmpGain

  """
  The explicitRoi field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitRoi: GmosRoi

  """
  The explicitWavelengthDithers field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitWavelengthDithers: [WavelengthDitherInput!]

  """
  The explicitSpatialOffsets field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitSpatialOffsets: [OffsetComponentInput!]
}

"""
GMOS North stage mode
"""
enum GmosNorthStageMode {
  """
  GmosNorthStageMode NoFollow
  """
  NO_FOLLOW

  """
  GmosNorthStageMode FollowXyz
  """
  FOLLOW_XYZ

  """
  GmosNorthStageMode FollowXy
  """
  FOLLOW_XY

  """
  GmosNorthStageMode FollowZ
  """
  FOLLOW_Z
}

"""
Unchanging (over the course of the sequence) configuration values
"""
type GmosNorthStatic {
  """
  Stage mode
  """
  stageMode: GmosNorthStageMode!

  """
  Detector in use (always HAMAMATSU for recent and new observations)
  """
  detector: GmosNorthDetector!

  """
  Is MOS Pre-Imaging Observation
  """
  mosPreImaging: MosPreImaging!

  """
  Nod-and-shuffle configuration
  """
  nodAndShuffle: GmosNodAndShuffle
}

"""
GMOS North static configuration input parameters
"""
input GmosNorthStaticInput {
  """
  GMOS North Stage Mode (default to FOLLOW_XY)
  """
  stageMode: GmosNorthStageMode

  """
  GMOS North Detector option (defaults to HAMAMATSU)
  """
  detector: GmosNorthDetector

  """
  Whether this is a MOS pre-imaging observation (defaults to IS_NOT_MOS_PRE_IMAGING)
  """
  mosPreImaging: MosPreImaging

  """
  GMOS Nod And Shuffle configuration
  """
  nodAndShuffle: GmosNodAndShuffleInput

}

"""
GmosNorth step with potential breakpoint
"""
type GmosNorthStep {
  """
  Instrument configuration for this step
  """
  instrumentConfig: GmosNorthDynamic!

  """
  Step id
  """
  id: StepId!

  """
  Whether to pause before the execution of this step
  """
  breakpoint: Breakpoint!

  """
  The sequence step itself
  """
  stepConfig: StepConfig!

  "The telescope configuration at this step."
  telescopeConfig: TelescopeConfig!

  """
  Time estimate for this step's execution
  """
  estimate: StepEstimate!

  """
  Observe class for this step
  """
  observeClass: ObserveClass!

}

"""
GmosSouth atom, a collection of steps that should be executed in their entirety
"""
type GmosSouthAtom {
  """
  Atom id
  """
  id: AtomId!

  """
  Optional description of the atom.
  """
  description: String

  """
  Observe class for this atom as a whole (combined observe class for each of
  its steps).
  """
  observeClass: ObserveClass!

  """
  Individual steps that comprise the atom
  """
  steps: [GmosSouthStep!]!
}

"""
GmosSouth Detector type
"""
enum GmosSouthDetector {
  E2_V

  HAMAMATSU
}

"""
GMOS South dynamic step configuration
"""
type GmosSouthDynamic {
  """
  GMOS exposure time
  """
  exposure: TimeSpan!

  """
  GMOS CCD Readout
  """
  readout: GmosCcdMode!

  """
  GMOS detector x offset
  """
  dtax: GmosDtax!

  """
  GMOS region of interest
  """
  roi: GmosRoi!

  """
  GMOS South grating
  """
  gratingConfig: GmosSouthGratingConfig

  """
  GMOS South filter
  """
  filter: GmosSouthFilter

  """
  GMOS South FPU
  """
  fpu: GmosSouthFpu
}

"""
GMOS South instrument configuration input
"""
input GmosSouthDynamicInput {
  """
  Exposure time
  """
  exposure: TimeSpanInput!

  """
  GMOS CCD readout
  """
  readout: GmosCcdModeInput!

  """
  GMOS detector x offset
  """
  dtax: GmosDtax!

  """
  GMOS region of interest
  """
  roi: GmosRoi!

  """
  GMOS South grating
  """
  gratingConfig: GmosSouthGratingConfigInput

  """
  GMOS South filter
  """
  filter: GmosSouthFilter

  """
  GMOS South FPU
  """
  fpu: GmosSouthFpuInput
}

"""
GMOS South Execution Config
"""
type GmosSouthExecutionConfig {
  """
  GMOS South static configuration
  """
  static: GmosSouthStatic!

  """
  GMOS South acquisition execution sequence.  Pass `true` to (re)start
  acquisition from the initial step.
  """
  acquisition(reset: Boolean = false): GmosSouthExecutionSequence

  """
  GMOS South science execution
  """
  science: GmosSouthExecutionSequence
}

"""
Next atom to execute and potential future atoms.
"""
type GmosSouthExecutionSequence {

  """
  Next atom to execute.
  """
  nextAtom: GmosSouthAtom!

  """
  (Prefix of the) remaining atoms to execute, if any.
  """
  possibleFuture: [GmosSouthAtom!]!

  """
  Whether there are more anticipated atoms than those that appear in
  'possibleFuture'.
  """
  hasMore: Boolean!

}

"""
GMOS South FPU option, either builtin or custom mask
"""
type GmosSouthFpu {
  """
  The custom mask, if in use
  """
  customMask: GmosCustomMask

  """
  GMOS South builtin FPU, if in use
  """
  builtin: GmosSouthBuiltinFpu
}

"""
GMOS South FPU input parameters (choose custom or builtin).
"""
input GmosSouthFpuInput {
  """
  Custom mask FPU option
  """
  customMask: GmosCustomMaskInput

  """
  Builtin FPU option
  """
  builtin: GmosSouthBuiltinFpu
}

"""
GMOS South Grating Configuration
"""
type GmosSouthGratingConfig {
  """
  GMOS South Grating
  """
  grating: GmosSouthGrating!

  """
  GMOS grating order
  """
  order: GmosGratingOrder!

  """
  Grating wavelength
  """
  wavelength: Wavelength!
}

"""
GMOS South grating input parameters
"""
input GmosSouthGratingConfigInput {
  """
  GmosGmosSouth grating
  """
  grating: GmosSouthGrating!

  """
  GMOS grating order
  """
  order: GmosGratingOrder!

  """
  Grating wavelength
  """
  wavelength: WavelengthInput!
}

"""
Edit or create GMOS South Long Slit advanced configuration
"""
input GmosSouthLongSlitInput {

  """
  The grating field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  grating: GmosSouthGrating

  """
  The filter field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  filter: GmosSouthFilter

  """
  The fpu field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  fpu: GmosSouthBuiltinFpu

  """
  The centralWavelength field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  centralWavelength: WavelengthInput

  """
  The explicitXBin field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitXBin: GmosXBinning

  """
  The explicitYBin field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitYBin: GmosYBinning

  """
  The explicitAmpReadMode field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitAmpReadMode: GmosAmpReadMode

  """
  The explicitAmpGain field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitAmpGain: GmosAmpGain

  """
  The explicitRoi field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitRoi: GmosRoi

  """
  The explicitWavelengthDithers field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitWavelengthDithers: [WavelengthDitherInput!]

  """
  The explicitSpatialOffsets field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitSpatialOffsets: [OffsetComponentInput!]

}

"""
GMOS South stage mode
"""
enum GmosSouthStageMode {
  """
  GmosSouthStageMode NoFollow
  """
  NO_FOLLOW

  """
  GmosSouthStageMode FollowXyz
  """
  FOLLOW_XYZ

  """
  GmosSouthStageMode FollowXy
  """
  FOLLOW_XY

  """
  GmosSouthStageMode FollowZ
  """
  FOLLOW_Z
}

"""
Unchanging (over the course of the sequence) configuration values
"""
type GmosSouthStatic {

  """
  Stage mode
  """
  stageMode: GmosSouthStageMode!

  """
  Detector in use (always HAMAMATSU for recent and new observations)
  """
  detector: GmosSouthDetector!

  """
  Is MOS Pre-Imaging Observation
  """
  mosPreImaging: MosPreImaging!

  """
  Nod-and-shuffle configuration
  """
  nodAndShuffle: GmosNodAndShuffle
}

"""
GMOS South static configuration input parameters
"""
input GmosSouthStaticInput {

  """
  GMOS South Stage Mode (defaults to FOLLOW_XYZ)
  """
  stageMode: GmosSouthStageMode

  """
  GMOS South Detector option (defaults to HAMAMATSU)
  """
  detector: GmosSouthDetector

  """
  Whether this is a MOS pre-imaging observation (defaults to IS_NOT_MOS_PRE_IMAGING)
  """
  mosPreImaging: MosPreImaging

  """
  GMOS Nod And Shuffle configuration
  """
  nodAndShuffle: GmosNodAndShuffleInput

}

"""
GmosSouth step with potential breakpoint
"""
type GmosSouthStep {
  """
  Instrument configuration for this step
  """
  instrumentConfig: GmosSouthDynamic!

  """
  Step id
  """
  id: StepId!

  """
  Whether to pause before the execution of this step
  """
  breakpoint: Breakpoint!

  """
  The sequence step itself
  """
  stepConfig: StepConfig!

  "The telescope configuration at this step."
  telescopeConfig: TelescopeConfig!

  """
  Time estimate for this step's execution
  """
  estimate: StepEstimate!

  """
  Observe class for this step
  """
  observeClass: ObserveClass!

}

input CloneGroupInput {
  groupId: GroupId!
  SET: GroupPropertiesInput
}

type CloneGroupResult {
  originalGroup: Group!
  newGroup: Group!
}

"""
Whether guiding is enabled for a particular science step.
"""
enum GuideState {
  """
  Guiding enabled.
  """
  ENABLED

  """
  Guiding disabled.
  """
  DISABLED
}

"""
Hour angle range creation parameters
"""
input HourAngleRangeInput {
  minHours: BigDecimal
  maxHours: BigDecimal
}

"""
A line flux value with integrated units
"""
input LineFluxIntegratedInput {
  value: PosBigDecimal!
  units: LineFluxIntegratedUnits!
}

"""
A line flux value with surface units
"""
input LineFluxSurfaceInput {
  value: PosBigDecimal!
  units: LineFluxSurfaceUnits!
}

"Link user"
input LinkUserInput {

  "The program to add a user to."
  programId: ProgramId!

  "The user to be added."
  userId: UserId!

  "The role this user will play in the program."
  role: ProgramUserRole!

  "Partner associated with this user, if any."
  partnerLink: PartnerLinkInput

}


scalar UserInvitationId
scalar UserInvitationKey

"Create an invitation."
input CreateUserInvitationInput {

  "The program to add a user to."
  programId: ProgramId!

  "The recipient to whom the invitation should be sent."
  recipientEmail: EmailAddress!

  "The role this user will play in the program."
  role: ProgramUserRole!

  "Partner associated with this user, if any."
  partnerLink: PartnerLinkInput

}

enum UserInvitationStatus {

  "This invitation has not been used."
  PENDING,

  "This invitation was redeemed."
  REDEEMED,

  "This invitation was declined."
  DECLINED,

  "This invitation was revoked, and can no longer be redeemed."
  REVOKED

}

"Invitation"
type UserInvitation {

  "Id"
  id: UserInvitationId!

  "Invitation status."
  status: UserInvitationStatus!

  "User who issued the invitation."
  issuer: User!

  "Recipient email address."
  recipientEmail: EmailAddress!

  "User who redeemed the invitation, if any."
  redeemer: User

  "The program the redeemer will be added to."
  program: Program!

  "The role the redeemer will play in the program."
  role: ProgramUserRole!

  "Redeemer's partner, if any."
  partnerLink: PartnerLink!

  "The email sent for the invitation"
  email: Email
}

type CreateUserInvitationResult {

  "The created invitation."
  invitation: UserInvitation!

  "Give this key to the person you wish to invite. They can later redeem the invitation."
  key: UserInvitationKey!

}

input RedeemUserInvitationInput {

  key: UserInvitationKey!

  "Pass false here to decline the invitation."
  accept: Boolean = true

}

type RedeemUserInvitationResult {

  "The redeemed invitation."
  invitation: UserInvitation!

}

input RevokeUserInvitationInput {
  id: UserInvitationId!
}

type RevokeUserInvitationResult {

  "The revoked invitation."
  invitation: UserInvitation!

}

type LinkUserResult {
  user: ProgramUser!
}

"""
MOS pre-imaging observation
"""
enum MosPreImaging {
  """
  MosPreImaging IsMosPreImaging
  """
  IS_MOS_PRE_IMAGING

  """
  MosPreImaging IsNotMosPreImaging
  """
  IS_NOT_MOS_PRE_IMAGING
}

type Mutation {

  """
  Logs  observing conditions to the Chronicle. This operation is permitted only for staff and
  service users.
  """
  addConditionsEntry(
    input: ConditionsEntryInput
  ): AddConditionsEntryResult!

  """
  Adds a new atom event.
  """
  addAtomEvent(
    """
    Describes the atom event to add.  All events are associated with a
    particular visit (see 'record{InstrumentName}Visit').  Atom events are
    further associated with an an observation id and an atom id. Each atom event
    identifies the stage through which the atom execution is passing.
    """
    input: AddAtomEventInput!
  ): AddAtomEventResult!

  """
  Adds a new dataset event associated with the given visit.  The
  generation of a single dataset will produce multiple events as it
  transitions through the observe, readout and write stages.
  """
  addDatasetEvent(

    """
    Describes the dataset event to add.  All events are associated with a
    particular visit (see 'record{InstrumentName}Visit').  Dataset events
    are further associated with an observation, step and index because a
    step may produce multiple datasets. (See also 'record{InstrumentName}Step'.)
    """
    input: AddDatasetEventInput!

  ): AddDatasetEventResult!

  """
  Looks up or creates (if necessary) a user associated with a given ORCID id and
  adds it to the given program.  No invitation is sent as a result of this
  operation.
  """
  addProgramUser(
    input: AddProgramUserInput!
  ): AddProgramUserResult!

  """
  Adds a sequence event associated with the given visit. Multiple events
  will be produced during the execution of a sequence as it is started,
  paused, continued, etc.
  """
  addSequenceEvent(

    """
    Describes the sequence event to add.  All events are associated with a
    particular visit (see 'record{InstrumentName}Visit').  Sequence events
    are further associated with an observation.  Each sequence event identifies
    the sequence command that acted upon the sequence.
    """
    input: AddSequenceEventInput!

  ): AddSequenceEventResult!

  """
  Adds a new slew event associated with the given visit.
  """
  addSlewEvent(

    """
    Describes the slew event to add.  All events are associated with a
    particular visit (see 'record{InstrumentName}Visit').
    """
    input: AddSlewEventInput!

  ): AddSlewEventResult!

  """
  Adds a new step event associated with the given step. Multiple events
  will be produced during the execution of a single step as it
  transitions through configure and observe stages.
  """
  addStepEvent(

    """
    Describes the step event to add.  All events are associated with a
    particular step (see 'record{InstrumentName}Step'). Each step event
    identifies the stage through which the step execution is passing.
    """
    input: AddStepEventInput!

  ): AddStepEventResult!

  """
  Adds a new time accounting correction for a particular observation.  Note
  that time accounting corrections are additive and cannot be adjusted or
  deleted except via a future correction.  For example, to undo the impact
  of an 'Add' operation, a new 'Subtract' operation of the same amount can
  be introduced.
  """
  addTimeChargeCorrection(
    input: AddTimeChargeCorrectionInput!
  ): AddTimeChargeCorrectionResult!

  cloneObservation(
    """
    Parameters for cloning an existing observation
    """
    input: CloneObservationInput!
  ): CloneObservationResult!

  """
  Copy this group and its contents, recursively, as a sibling of itself.
  """
  cloneGroup(
    input: CloneGroupInput!
  ): CloneGroupResult!

  """
  Makes a copy of an existing target, setting it to unobserved and to PRESENT.  If `REPLACE_IN` observationIds are specified in the input, the clone will replace the existing target in those observations
  """
  cloneTarget(
    """
    Parameters for cloning an existing target
    """
    input: CloneTargetInput!
  ): CloneTargetResult!

  """
  Creates a Call for Proposals.  Requires staff access.
  """
  createCallForProposals(
    input: CreateCallForProposalsInput!
  ): CreateCallForProposalsResult!

  "Creates a new observation according to provided parameters."
  createGroup(
    "Group description."
    input: CreateGroupInput!
  ): CreateGroupResult!

  """
  Creates a new observation according to provided parameters
  """
  createObservation(
    """
    Observation description
    """
    input: CreateObservationInput!
  ): CreateObservationResult!

  """
  Creates a new program according to provided properties
  """
  createProgram(
    """
    Program description
    """
    input: CreateProgramInput!
  ): CreateProgramResult!

  """
  Creates a new proposal according to the provided properties
  """
  createProposal(
    """
    Proposal description
    """
    input: CreateProposalInput!
  ): CreateProposalResult

  """
  Creates a new target according to the provided parameters.  Only one of sidereal or nonsidereal may be specified.
  """
  createTarget(
    """
    Target description.  One (and only one) of sidereal or nonsidereal must be specified.
    """
    input: CreateTargetInput!
  ): CreateTargetResult!

  """
  Deletes the given program's proposal, if any.
  """
  deleteProposal(
    input: DeleteProposalInput!
  ): DeleteProposalResult!

  """
  Link a user to a program. Any existing link will be replaced.
  This operation is available only to Admin and Service users.
  """
  linkUser(input: LinkUserInput!): LinkUserResult!

  "Record a new atom"
  recordAtom(
    "Atom configuration parameters"
    input: RecordAtomInput!
  ): RecordAtomResult!

  """
  Records a new dataset.  This dataset may be subsequently referenced by dataset events.
  """
  recordDataset(
    """
    Describes the dataset to add.
    """
    input: RecordDatasetInput!
  ): RecordDatasetResult!

  "Record a new GMOS North step"
  recordGmosNorthStep(
    "GMOS North step configuration parameters"
    input: RecordGmosNorthStepInput!
  ): RecordGmosNorthStepResult!

  """
  Record a new GMOS North visit
  """
  recordGmosNorthVisit(
    """
    Visit creation parameters
    """
    input: RecordGmosNorthVisitInput!
  ): RecordGmosNorthVisitResult!

  "Record a new GMOS South step"
  recordGmosSouthStep(
    "GmosSouth step configuration parameters"
    input: RecordGmosSouthStepInput!
  ): RecordGmosSouthStepResult!

  """
  Record a new GMOS South visit
  """
  recordGmosSouthVisit(
    """
    Visit creation parameters
    """
    input: RecordGmosSouthVisitInput!
  ): RecordGmosSouthVisitResult!

  """
  Set the allocations for a program.
  """
  setAllocations(input: SetAllocationsInput!): SetAllocationsResult!

  """
  Set the name of the guide target for an observation.
  """
  setGuideTargetName(input: SetGuideTargetNameInput!): SetGuideTargetNameResult!

  "Set the program reference."
  setProgramReference(input: SetProgramReferenceInput!): SetProgramReferenceResult!

  "Set the proposal status."
  setProposalStatus(input: SetProposalStatusInput!): SetProposalStatusResult!

  """
  Unlink a user from a program.
  This operation is available only to Admin and Service users.
  """
  unlinkUser(input: UnlinkUserInput!): UnlinkUserResult!

  """
  Update asterisms, adding or deleting targets, in (potentially) multiple
  observations at once.
  """
  updateAsterisms(
    """
    Bulk update asterism
    """
    input: UpdateAsterismsInput!
  ): UpdateAsterismsResult!

  updateAttachments(
    """
    Parameters for updating existing attachments.
    """
    input: UpdateAttachmentsInput!
  ): UpdateAttachmentsResult!

  "Update existing calls for proposals."
  updateCallsForProposals(
    "Parameters for editing existing calls for proposals."
    input: UpdateCallsForProposalsInput!
  ): UpdateCallsForProposalsResult!

  updateDatasets(
    """
    Parameters for editing existing datasets
    """
    input: UpdateDatasetsInput!
  ): UpdateDatasetsResult!

  updateGroups(
    """
    Parameters for editing existing groups
    """
    input: UpdateGroupsInput!
  ): UpdateGroupsResult!

  """
  Updates existing observations
  """
  updateObservations(
    """
    Parameters for editing existing observations.
    """
    input: UpdateObservationsInput!
  ): UpdateObservationsResult!


  """
  Update existing configuration requests.
  """
  updateConfigurationRequests(
    input: UpdateConfigurationRequestsInput!
  ): UpdateConfigurationRequestsResult!

  """
  Updates existing observations times (execution and duration)
  """
  updateObservationsTimes(
    """
    Parameters for editing existing observations times.
    """
    input: UpdateObservationsTimesInput!
  ): UpdateObservationsResult!

  """
  Updates existing programs.
  """
  updatePrograms(
    """
    Parameters for updating existing programs.
    """
    input: UpdateProgramsInput!
  ): UpdateProgramsResult!

  "Updates existing program users."
  updateProgramUsers(

    "Parameters for updating an existing program user."
    input: UpdateProgramUsersInput!

  ): UpdateProgramUsersResult!

  """
  Updates an existing proposal.
  """
  updateProposal(
    """
    Parameters for updating an existing proposal.
    """
    input: UpdateProposalInput!
  ): UpdateProposalResult!

  """
  Updates existing targets
  """
  updateTargets(
    """
    Parameters for updating existing targets.
    """
    input: UpdateTargetsInput!
  ): UpdateTargetsResult!

  """
  Create a user invitation.
  """
  createUserInvitation(
    input: CreateUserInvitationInput!
  ): CreateUserInvitationResult!


  """
  Redeem a user invitation.
  """
  redeemUserInvitation(
    input: RedeemUserInvitationInput!
  ): RedeemUserInvitationResult!

  """
  Revoke a user invitation.
  """
  revokeUserInvitation(
    input: RevokeUserInvitationInput!
  ): RevokeUserInvitationResult!

  """
  Create a configuration request.
  """
  createConfigurationRequest(
    input: CreateConfigurationRequestInput!
  ): ConfigurationRequest!

  """
  Sets the workflow state for the specified observation. The transition must be valid
  according to the current workflow. Returns the updated workflow.
  """
  setObservationWorkflowState(
    input: SetObservationWorkflowStateInput!
  ): ObservationWorkflow

}

input SetObservationWorkflowStateInput {
  observationId: ObservationId!
  state: ObservationWorkflowState!
}

"""
Nonsidereal target parameters.  Supply `keyType` and `des` or `key`
"""
input NonsiderealInput {
  """
  The keyType field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  keyType: EphemerisKeyType

  """
  The des field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  des: NonEmptyString

  """
  The key field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  key: NonEmptyString
}

"""
Event sent when a new object is created or updated
"""
type ObservationEdit { #implements Event {
  """
  Type of edit
  """
  editType: EditType!

  """
  The observationId of the edited object
  """
  observationId: ObservationId!

  """
  Edited object, can be null if the value was deleted
  """
  value: Observation

}

"""
Event sent when a configuration request is created or updated
"""
type ConfigurationRequestEdit {

  """
  Type of edit
  """
  editType: EditType!

  """
  The id of the edited configuration request
  """
  configurationRequestId: ConfigurationRequestId!

  """
  Edited configuration request, can be null if the value was deleted
  """
  configurationRequest: ConfigurationRequest

}


"""
Configuration request properties.
"""
input ConfigurationRequestProperties {
  status: ConfigurationRequestStatus
}

"""
Observation properties
"""
input ObservationPropertiesInput {
  """
  Subtitle adds additional detail to the target-based observation title, and is both optional and nullable
  """
  subtitle: NonEmptyString

  """
  The science band to assign to this observation.  Set to `null` to remove the
  science band.
  """
  scienceBand: ScienceBand

  """
  Position angle constraint, if any. Set to null to remove all position angle constraints
  """
  posAngleConstraint: PosAngleConstraintInput

  """
  The targetEnvironment defaults to empty if not specified on creation, and may be edited but not deleted
  """
  targetEnvironment: TargetEnvironmentInput

  """
  The constraintSet defaults to standard values if not specified on creation, and may be edited but not deleted
  """
  constraintSet: ConstraintSetInput

  """
  The timingWindows defaults to empty if not specified on creation, and may be edited by specifying a new whole array
  """
  timingWindows: [TimingWindowInput!]

  """
  The attachments defaults to empty if not specified on creation, and may be edited by specifying a new whole array
  """
  attachments: [AttachmentId!]

  """
  The scienceRequirements defaults to spectroscopy if not specified on creation, and may be edited but not deleted
  """
  scienceRequirements: ScienceRequirementsInput

  """
  The observingMode describes the chosen observing mode and instrument, is optional and may be deleted
  """
  observingMode: ObservingModeInput

  """
  Whether the observation is considered deleted (defaults to PRESENT) but may be edited
  """
  existence: Existence

  """
  Enclosing group, if any.
  """
  groupId: GroupId

  """
  Index in enclosing group or at the top level if ungrouped. If left unspecified on creation, observation will be added last in its enclosing group or at the top level. Cannot be set to null.
  """
  groupIndex: NonNegShort

  """
  Set the notes for  thhe observer
  """
  observerNotes: NonEmptyString
  
}

"""
Observation times properties
"""
input ObservationTimesInput {
  """
  Expected execution time used for time-dependent calculations such as average parallactic angle and guide star selection.
  """
  observationTime: Timestamp

  """
  Expected observation duration used in conjunction with observationTime. If not set, remaining observation time is used.
  """
  observationDuration: TimeSpanInput
}

type Offset {
  """
  Offset in p
  """
  p: OffsetP!

  """
  Offset in q
  """
  q: OffsetQ!
}

"""
Offset component (p or q) input parameters. Choose one angle units definition.
"""
input OffsetComponentInput {

  """
  Angle in µas
  """
  microarcseconds: Long

  """
  Angle in mas
  """
  milliarcseconds: BigDecimal

  """
  Angle in arcsec
  """
  arcseconds: BigDecimal
}

"""
Offset input.  Define offset in p and q.
"""
input OffsetInput {

  """
  Offset in p
  """
  p: OffsetComponentInput!

  """
  Offset in q
  """
  q: OffsetComponentInput!

}

"""
Parallax, choose one of the available units
"""
input ParallaxInput {
  microarcseconds: Long
  milliarcseconds: BigDecimal
}

"""
Gemini Partners
"""
enum Partner {
   "Argentina"            AR
   "Brazil"               BR
   "Canada"               CA
   "Chile"                CL
   "Korea"                KR
   "University of Hawaii" UH
   "United States"        US
}

"""
Partner link options (and `PartnerLink` discriminator). A user / partner
relationship is one of (a) the user is associated with a particular partner
(i.e., `HAS_PARTNER`), (b) the user is explicitly associated with no partner
(i.e., `HAS_NON_PARTNER`), or (c) the link is simply not set.
"""
enum PartnerLinkType {
  HAS_PARTNER
  HAS_NON_PARTNER
  HAS_UNSPECIFIED_PARTNER
}

"Represents the association of a user with a `Partner`, if any."
interface PartnerLink {

  "Partner link discriminator."
  linkType: PartnerLinkType!

}

"""
A `PartnerLink` employed when a user is associated with a specific
`Partner`.
"""
type HasPartner implements PartnerLink {
  "Always `HAS_PARTNER`"
  linkType: PartnerLinkType!

  "The associated partner."
  partner: Partner!
}

"""
A `PartnerLink` employed when a user is explicitly associated with
no `Partner`.
"""
type HasNonPartner implements PartnerLink {
  "Always `HAS_NON_PARTNER"
  linkType: PartnerLinkType!
}

"""
A `PartnerLink` employed when a user's `PartnerLink` has not
(yet) been made.
"""
type HasUnspecifiedPartner implements PartnerLink {
  "Always `HAS_UNSPECIFIED_PARTNER`"
  linkType: PartnerLinkType!
}

"""
Describes the user / partner association.  Only one of `partner` or `linkType`
should be specified, but as long as they are consistent both may be supplied.
"""
input PartnerLinkInput {

  """
  Describes the state of the association between a user and a partner. The
  link type is assumed to be `HAS_PARTNER` if the `partner` is specified.
  Otherwise, if `partner` is `null`, the link type is required.
  """
  linkType: PartnerLinkType

  """
  If the user should be associated with a particular partner, it is specified
  here.  Only set `partner` or `linkType`, but not both.
  """
  partner: Partner

}

"""
Partner splits detail how requested time for a Queue or Classical proposal
should be distributed amongst Gemini partners.
"""
type PartnerSplit {

  partner: Partner!

  "Percentage of requested time that should be associated with the partner."
  percent: IntPercent!
}

"""
Time request percentage that should be associated with a particular partner for
Queue and Classical proposals.
"""
input PartnerSplitInput {

  partner: Partner!

  "Percentage of requested time that should be associated with the partner."
  percent: IntPercent!
}

"""
Create or edit position angle constraint.  If not specified, then the
position angle required to reach the best guide star option will be used.

"""
input PosAngleConstraintInput {

  """
  The constraint mode field determines whether the angle field is respected
  or ignored.
  """
  mode: PosAngleConstraintMode

  """
  The fixed position angle that is used when the mode is FIXED, ALLOW_FLIP or
  PARALLACTIC_OVERRIDE.  Set but ignored when UNBOUNDED or AVERAGE_PARALLACTIC.
  """
  angle: AngleInput
}

"""
An `Long` in the range from 1 to 9223372036854775807
"""
scalar PosLong

"""
Event sent when a new object is created or updated
"""
type ProgramEdit { #implements Event {
  """
  Type of edit
  """
  editType: EditType!

  """
  Edited object
  """
  value: Program!
  id: Long! @deprecated(reason: "id is no longer computed; a constant value is returned")
}

"""
Program properties
"""
input ProgramPropertiesInput {
  """
  The program name, which is both optional and nullable
  """
  name: NonEmptyString

  """
  Sets the GOA properties for this program.  If not specified on create,
  default values are used.
  """
  goa: GoaPropertiesInput

  """
  Whether the program is considered deleted (defaults to PRESENT) but may be edited
  """
  existence: Existence
}

"""
Editable properties that define a program / user connection.
"""
input ProgramUserPropertiesInput {

  "The user's partner."
  partnerLink: PartnerLinkInput

  """
  The fallback profile may used when the ORCiD user profile is not set or not
  shared publicly.
  """
  fallbackProfile: UserProfileInput

  "The user's educational status."
  educationalStatus: EducationalStatus

  "Is a thesis included in the proposal."
  thesis: Boolean

  "The user's reported gender."
  gender: Gender
}

"""
The role a user a plays when assigned to a program.
"""
enum ProgramUserRole {
  "Primary Investigator"               PI
  "Co-Investigator"                    COI
  "Co-Investigator (read-only access)" COI_RO
  "Staff/Partner Primary Support"      SUPPORT_PRIMARY
  "Staff/Partner Secondary Support"    SUPPORT_SECONDARY
}

"""
The type of support role.
"""
enum ProgramUserSupportRoleType {
  "Staff support"   STAFF
  "Partner support" PARTNER
}

"""
An assignment of a user to a program.
"""
type ProgramUser {
  role:              ProgramUserRole!
  partnerLink:       PartnerLink!
  program:           Program
  user:              User

  fallbackProfile:   UserProfile!

  """
  User educational status. PHD/Undergrad/Grad/Other
  """
  educationalStatus: EducationalStatus

  """
  Users' reported gender.
  """
  gender: Gender

  """
  Flag indicating whether the user's proposal is part of a thesis.
  """
  thesis: Boolean
}

"""
Proper motion component, choose one of the available units
"""
input ProperMotionComponentInput {
  microarcsecondsPerYear: Long
  milliarcsecondsPerYear: BigDecimal
}

"""
Proper motion, choose one of the available units
"""
input ProperMotionInput {
  ra: ProperMotionComponentInput!
  dec: ProperMotionComponentInput!
}

"""
Proposal properties that depend on the particular call for proposals associated
with this proposal.
"""
interface ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

}

"""
Proposal properties for Regular Semester (Classical) CallForProposals.
"""
type Classical implements ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

  """
  Minimum percentage of observing time required to consider this proposal
  successful.
  """
  minPercentTime: IntPercent!

  "Describes how time for the program will be apportioned across partners."
  partnerSplits: [PartnerSplit!]!

  # TODO: AEON / Multi-facility
  # TODO: JWST Synergy
  # TODO: US Long Term
  # TODO: Visitors?

}

"""
Proposal properties for Demo Science CallForProposals.
"""
type DemoScience implements ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

  """
  Whether (and how) the observations in this proposal are available for Target
  of Opportunity triggering.
  """
  toOActivation: ToOActivation!

  """
  Minimum percentage of observing time required to consider this proposal
  successful.
  """
  minPercentTime: IntPercent!

}

"""
Proposal properties for Director's Time CallForProposals.
"""
type DirectorsTime implements ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

  """
  Whether (and how) the observations in this proposal are available for Target
  of Opportunity triggering.
  """
  toOActivation: ToOActivation!

  """
  Minimum percentage of observing time required to consider this proposal
  successful.
  """
  minPercentTime: IntPercent!

}

"""
Proposal properties for Fast Turnaround CallForProposals.
"""
type FastTurnaround implements ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

  """
  Whether (and how) the observations in this proposal are available for Target
  of Opportunity triggering.
  """
  toOActivation: ToOActivation!

  """
  Minimum percentage of observing time required to consider this proposal
  successful.
  """
  minPercentTime: IntPercent!

  """
  Partner associated with this FT proposal.  This is optional until submission,
  by which time it must be defined.
  """
  piAffiliation: Partner

  # TODO: Reviewer?
}

"""
Proposal properties for Large Program CallForProposals.
"""
type LargeProgram implements ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

  """
  Whether (and how) the observations in this proposal are available for Target
  of Opportunity triggering.
  """
  toOActivation: ToOActivation!

  """
  Minimum percentage of observing time (first semester) required to consider this
  proposal successful.
  """
  minPercentTime: IntPercent!

  """
  Minimum percentage of the total observing time (over all semesters) required
  to consider this proposal successful.
  """
  minPercentTotalTime: IntPercent!

  """
  Total time requested (over multiple all semesters) for this proposal.
  """
  totalTime: TimeSpan!

  # TODO: AEON / Multi-facility
  # TODO: JWST Synergy

}

"""
Proposal properties for Regular Semester (Poor Weather) CallForProposals.
"""
type PoorWeather implements ProposalType {
  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!
}

"""
Proposal properties for Regular Semester (Queue) CallForProposals.
"""
type Queue implements ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

  """
  Whether (and how) the observations in this proposal are available for Target
  of Opportunity triggering.
  """
  toOActivation: ToOActivation!

  """
  Minimum percentage of observing time required to consider this proposal
  successful.
  """
  minPercentTime: IntPercent!

  """
  Describes how time for the program will be apportioned across partners.
  """
  partnerSplits: [PartnerSplit!]!

  # TODO: Band 3 ?
  # TODO: AEON / Multi-facility
  # TODO: JWST Synergy
  # TODO: US Long Term

}

"""
Proposal properties for System Verification CallForProposals.
"""
type SystemVerification implements ProposalType {

  "The science type of this Call for Proposals."
  scienceSubtype: ScienceSubtype!

  """
  Whether (and how) the observations in this proposal are available for Target
  of Opportunity triggering.
  """
  toOActivation: ToOActivation!

  """
  Minimum percentage of observing time required to consider this proposal
  successful.
  """
  minPercentTime: IntPercent!

}

"""
Properties associated with particular proposal types.  Exactly one of
these should be set upon creation or editing.
"""
input ProposalTypeInput {

  classical: ClassicalInput

  demoScience: DemoScienceInput

  directorsTime: DirectorsTimeInput

  fastTurnaround: FastTurnaroundInput

  largeProgram: LargeProgramInput

  poorWeather: PoorWeatherInput

  queue: QueueInput

  systemVerification: SystemVerificationInput

}

input ClassicalInput {

  """
  The minimum percentage of time required to consider this proposal a success.
  If not set, 100% is assumed.
  """
  minPercentTime: IntPercent

  """
  The partnerSplits field specifies how time is apportioned over partners. This
  will default to empty but if specified, the partner percents must sum to 100.
  By submission time, it must be specified.
  """
  partnerSplits: [PartnerSplitInput!]

  # TODO: AEON / Multi-facility
  # TODO: JWST Synergy
  # TODO: US Long Term
  # TODO: Visitors?

}

input DemoScienceInput {

  """
  The toOActivation field is optional. If not specified when creating a
  proposal, it defaults to `NONE'.
  """
  toOActivation: ToOActivation

  """
  The minimum percentage of time required to consider this proposal a success.
  If not set, 100% is assumed.
  """
  minPercentTime: IntPercent

}

input DirectorsTimeInput {

  """
  The toOActivation field is optional. If not specified when creating a
  proposal, it defaults to `NONE'.
  """
  toOActivation: ToOActivation

  """
  The minimum percentage of time required to consider this proposal a success.
  If not set, 100% is assumed.
  """
  minPercentTime: IntPercent

}

input FastTurnaroundInput {

  """
  The toOActivation field is optional. If not specified when creating a
  proposal, it defaults to `NONE'.
  """
  toOActivation: ToOActivation

  """
  The minimum percentage of time required to consider this proposal a success.
  If not set, 100% is assumed.
  """
  minPercentTime: IntPercent

  """
  Partner associated with this FT proposal.  This is optional on creation but
  must be specified upon submission.
  """
  piAffiliation: Partner

  # TODO: Reviewer?

}

input LargeProgramInput {

  """
  The toOActivation field is optional. If not specified when creating a
  proposal, it defaults to `NONE'.
  """
  toOActivation: ToOActivation

  """
  The minimum percentage of time required (first semester) to consider this
  proposal a success. If not set, 100% is assumed.
  """
  minPercentTime: IntPercent

  """
  The minimum percentage of time required over the lifetime of the program to
  consider this proposal a success.  If not set, 100% is assumed.
  """
  minPercentTotalTime: IntPercent

  """
  The total time requested over the lifetime of the program.  If not set, zero
  hours are assumed.
  """
  totalTime: TimeSpanInput

  # TODO: AEON / Multi-facility
  # TODO: JWST Synergy

}

"""
The GraphQL specification requires that types and inputs have fields, even when
there is no useful data to include.  This enumeration provides a placeholder
value for an ignored field to satisfy the specification.
"""
enum Ignore {
  IGNORE
}

"""
Input for a poor weather proposal.  There are no fields to further specify a
poor weather proposal but GraphQL requires at least one field.  Therefore this
input includes a single optional 'ignore' field which need not be set.
"""
input PoorWeatherInput {

  """
  This field is not intended to be used (and may be left unset), but is required
  by the GraphQL specification.
  """
  ignore: Ignore

}

input QueueInput {

  """
  The toOActivation field is optional. If not specified when creating a
  proposal, it defaults to `NONE'.
  """
  toOActivation: ToOActivation

  """
  The minimum percentage of time required to consider this proposal a success.
  If not set, 100% is assumed.
  """
  minPercentTime: IntPercent

  """
  The partnerSplits field specifies how time is apportioned over partners. This
  will default to empty but if specified, the partner percents must sum to 100.
  By submission time, it must be specified.
  """
  partnerSplits: [PartnerSplitInput!]

  # TODO: Band 3 ?
  # TODO: AEON / Multi-facility
  # TODO: JWST Synergy
  # TODO: US Long Term

}

input SystemVerificationInput {

  """
  The toOActivation field is optional. If not specified when creating a
  proposal, it defaults to `NONE'.
  """
  toOActivation: ToOActivation

  """
  The minimum percentage of time required to consider this proposal a success.
  If not set, 100% is assumed.
  """
  minPercentTime: IntPercent

}

"""
Program proposal
"""
input ProposalPropertiesInput {

  """
  The title field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  title: NonEmptyString

  """
  The category field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  category: TacCategory

  """
  The abstract field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  abstract: NonEmptyString

  """
  Sets the associated Call for Proposals. This is optional upon creation, but
  must be set for a successful submission.  Also, the Call for Proposals type
  must agree with the proposal type (see 'type' below).  For example a Queue
  proposal must be submitted to a Regular Semester Call and a Demo Science
  proposal must be submitted to a Demo Science Call, etc.
  """
  callId: CallForProposalsId

  """
  Specifies the properties that depend on the call type. If not set on creation,
  a regular semester queue proposal is assumed.  The selected call properties
  must match the call (see 'callId' above) or a submission attempt will fail
  with an error. Call properties can be edited, but when switching the call
  type itself, all properties required for that type must be included.
  """
  type: ProposalTypeInput

}


"""
Radial velocity, choose one of the available units
"""
input RadialVelocityInput {
  centimetersPerSecond: Long
  metersPerSecond: BigDecimal
  kilometersPerSecond: BigDecimal
}

"""
Input parameters for creating a new atom record.
(stepCount is deprecated and will be ignored)
"""
input RecordAtomInput {
  visitId: VisitId!
  instrument: Instrument!
  sequenceType: SequenceType!
  stepCount: NonNegShort
  generatedId: AtomId
}

"The result of recording an atom."
type RecordAtomResult {
  "The newly added atom record itself."
  atomRecord: AtomRecord!
}

"Dataset creation parameters."
input RecordDatasetInput {
  "Corresponding Step id."
  stepId: StepId!

  "Dataset filename."
  filename: DatasetFilename!

  "Dataset QA State."
  qaState: DatasetQaState

  "Dataset comment."
  comment: NonEmptyString
}

"The result of recording a new dataset."
type RecordDatasetResult {

  "The new dataset that was added."
  dataset: Dataset!

}

"Input parameters for creating a new GmosNorth StepRecord"
input RecordGmosNorthStepInput {
  atomId:          AtomId!
  gmosNorth:       GmosNorthDynamicInput!
  stepConfig:      StepConfigInput!
  telescopeConfig: TelescopeConfigInput
  observeClass:    ObserveClass!
  generatedId:     StepId
}

"""
The result of recording a GmosNorth step.
"""
type RecordGmosNorthStepResult {
  """
  The newly added step record itself.
  """
  stepRecord: StepRecord!
}

"""
Input parameters for creating a new GmosNorthVisit
"""
input RecordGmosNorthVisitInput {
  observationId: ObservationId!
  gmosNorth:     GmosNorthStaticInput!
}

"""
The result of recording a GmosNorth visit.
"""
type RecordGmosNorthVisitResult {
  """
  The newly added visit record itself.
  """
  visit: Visit!
}

"""
Input parameters for creating a new GmosSouth StepRecord
"""
input RecordGmosSouthStepInput {
  atomId:          AtomId!
  gmosSouth:       GmosSouthDynamicInput!
  stepConfig:      StepConfigInput!
  telescopeConfig: TelescopeConfigInput
  observeClass:    ObserveClass!
  generatedId:     StepId
}

"""
The result of recording a GmosSouth step.
"""
type RecordGmosSouthStepResult {
  """
  The newly added step record itself.
  """
  stepRecord: StepRecord!
}

"""
Input parameters for creating a new GmosSouthVisit
"""
input RecordGmosSouthVisitInput {
  observationId: ObservationId!
  gmosSouth:     GmosSouthStaticInput!
}

"""
The result of recording a GmosSouth visit.
"""
type RecordGmosSouthVisitResult {
  """
  The newly added visit record itself.
  """
  visit: Visit!
}

"""
Right Ascension, choose one of the available units
"""
input RightAscensionInput {
  microarcseconds: Long
  microseconds: Long
  degrees: BigDecimal
  hours: BigDecimal
  hms: HmsString
}

"""
Science step
"""
type Science implements StepConfig {

  """
  Step type is always SCIENCE.
  """
  stepType: StepType!
}

"""
Which kind of smart gcal configuration is requested in a smart gcal step.
"""
enum SmartGcalType {
  ARC
  FLAT
  DAY_BASELINE
  NIGHT_BASELINE
}

"""
SmartGcal step configuration.
"""
type SmartGcal implements StepConfig {

  smartGcalType: SmartGcalType!

  """
  Step type is always SMART_GCAL.
  """
  stepType: StepType!

}

"""
Edit or create an observation's observing mode
"""
input ObservingModeInput {

  """
  The gmosNorthLongSlit field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  gmosNorthLongSlit: GmosNorthLongSlitInput

  """
  The gmosSouthLongSlit field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  gmosSouthLongSlit: GmosSouthLongSlitInput
}

"""
Edit science requirements
"""
input ScienceRequirementsInput {
  """
  The mode field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  mode: ScienceMode

  """
  The spectroscopy field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  spectroscopy: SpectroscopyScienceRequirementsInput
}

"""
Describes the program allocations.  Each partner and band combination should
appear at most once in the 'allocations' array.
"""
input SetAllocationsInput {
  programId:   ProgramId!
  allocations: [AllocationInput!]!
}

type SetAllocationsResult {
  allocations: [Allocation!]!
}

type SetupTime {

  """
  Full setup time estimate, including slew, configuration and target acquisition
  """
  full: TimeSpan!

  """
  A reduced setup time contemplating reacquiring a previously acquired target
  """
  reacquisition: TimeSpan!
}

"""
Input parameters for setting the guide star name for an observation.
Identify the observation to clone by specifying either its id or reference.  If
both are specified, they must refer to the same observation.  If neither is
specified, an error will be returned.
"""
input SetGuideTargetNameInput {
  observationId: ObservationId
  observationReference: ObservationReferenceLabel

  """
  The name of the guide star. This must satisfy the regular expression "^Gaia DR3 (-?\d+)$" where the
  numeric part is the Gaia source_id. Omit or set to null to delete.
  """
  targetName: NonEmptyString
}

"""
The result of setting the guide target name for an observation.
"""
type SetGuideTargetNameResult {
  observation: Observation
}

"""
Input for setting the program reference.  Identify the program to update with one
of `programId`, `proposalReference` or `programReference`.  If more than one of
these is specified, all must match.  Use `SET` to specify the new program
reference properties.
"""
input SetProgramReferenceInput {
  programId:         ProgramId
  proposalReference: ProposalReferenceLabel
  programReference:  ProgramReferenceLabel
  SET:               ProgramReferencePropertiesInput!
}

"""
Properties for the chosen program reference type.  Supply the value for exactly
one of the inputs.
"""
input ProgramReferencePropertiesInput {
  calibration:   ProgramReferencePropertiesCalibrationInput
  commissioning: ProgramReferencePropertiesCommissioningInput
  engineering:   ProgramReferencePropertiesEngineeringInput
  example:       ProgramReferencePropertiesExampleInput
  library:       ProgramReferencePropertiesLibraryInput
  monitoring:    ProgramReferencePropertiesMonitoringInput
  science:       ProgramReferencePropertiesScienceInput
  system:        ProgramReferencePropertiesSystemInput
}

type SetProgramReferenceResult {
  "The resulting program reference, if any."
  reference: ProgramReference
}

"""
Inputs required when updating or switching to a calibration program.
"""
input ProgramReferencePropertiesCalibrationInput {
  semester:   Semester!
  instrument: Instrument!
}

"""
Inputs required when updating or switching to a commissioning program.
"""
input ProgramReferencePropertiesCommissioningInput {
  semester:   Semester!
  instrument: Instrument!
}

"""
Inputs required when updating or switching to an engineering program.
"""
input ProgramReferencePropertiesEngineeringInput {
  semester:   Semester!
  instrument: Instrument!
}

"""
Inputs required when updating or switching to an example program.
"""
input ProgramReferencePropertiesExampleInput {
  instrument: Instrument!
}

"""
Inputs required when updating or switching to a library program.
"""
input ProgramReferencePropertiesLibraryInput {
  instrument:  Instrument!
  description: NonEmptyString!
}

"""
Inputs required when updating or switching to a monitoring program.
"""
input ProgramReferencePropertiesMonitoringInput {
  semester:   Semester!
  instrument: Instrument!
}

"""
Inputs required when updating or switching to a science program.
"""
input ProgramReferencePropertiesScienceInput {
  semester:       Semester!
  scienceSubtype: ScienceSubtype!
}

"""
Inputs required when updating or switching to a system program.
"""
input ProgramReferencePropertiesSystemInput {
  description: NonEmptyString!
}

"""
Input for setting the proposal status.  Identify the program to update with one
of `programId`, `proposalReference` or `programReference`.  If more than one of
these is specified, all must match.
"""
input SetProposalStatusInput {
  programId:         ProgramId
  proposalReference: ProposalReferenceLabel
  programReference:  ProgramReferenceLabel
  status:            ProposalStatus!
}

"""
  The result of setting the proposal status.
"""
type SetProposalStatusResult {
  """
  The program on which the proposal status was set. Returning the program allows checking
  the proposal reference, program reference and other values that can be affected by changing
  the proposal status.
  """
  program: Program!
}

"""
Sidereal target edit parameters
"""
input SiderealInput {
  """
  The ra field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  ra: RightAscensionInput

  """
  The dec field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  dec: DeclinationInput

  """
  The epoch field must be either specified or skipped altogether.  It cannot be unset with a null value.
  """
  epoch: EpochString

  """
  The properMotion field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  properMotion: ProperMotionInput

  """
  The radialVelocity field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  radialVelocity: RadialVelocityInput

  """
  The parallax field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  parallax: ParallaxInput

  """
  The catalogInfo field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  catalogInfo: CatalogInfoInput
}

"""
Signal-to-noise mode parameters
"""
input SignalToNoiseModeInput {
  """
  s/n value
  """
  value: SignalToNoise!
}

"""
Create or edit a source profile.  Exactly one of "point", "uniform" or "gaussian" is required.
"""
input SourceProfileInput {
  point: SpectralDefinitionIntegratedInput
  uniform: SpectralDefinitionSurfaceInput
  gaussian: GaussianInput
}

"""
Spectral definition input with integrated units.  Specify exactly one of "bandNormalized" or "emissionLines"
"""
input SpectralDefinitionIntegratedInput {
  bandNormalized: BandNormalizedIntegratedInput
  emissionLines: EmissionLinesIntegratedInput
}

"""
Spectral definition input with surface units.  Specify exactly one of "bandNormalized" or "emissionLines"
"""
input SpectralDefinitionSurfaceInput {
  bandNormalized: BandNormalizedSurfaceInput
  emissionLines: EmissionLinesSurfaceInput
}

"""
Edit or create spectroscopy science requirements
"""
input SpectroscopyScienceRequirementsInput {
  """
  The wavelength field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  wavelength: WavelengthInput

  """
  The resolution field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  resolution: PosInt

  """
  The signalToNoise field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  signalToNoise: SignalToNoise

  """
  The signalToNoiseAt field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  signalToNoiseAt: WavelengthInput

  """
  The wavelengthCoverage field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  wavelengthCoverage: WavelengthInput

  """
  The focalPlane field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  focalPlane: FocalPlane

  """
  The focalPlaneAngle field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  focalPlaneAngle: AngleInput

  """
  The capabilities field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  capability: SpectroscopyCapabilities
}

"""
Step (bias, dark, gcal, science, etc.)
"""
interface StepConfig {
  """
  Step type
  """
  stepType: StepType!
}

"""
Step configuration.  Choose exactly one step type.
"""
input StepConfigInput {

  """
  Bias step creation option
  """
  bias: Boolean

  """
  Dark step creation option
  """
  dark: Boolean

  """
  GCAL step creation option
  """
  gcal: StepConfigGcalInput

  """
  Science step creation option
  """
  science: Boolean

  """
  Smart gcal creation option
  """
  smartGcal: StepConfigSmartGcalInput

}

"""
GCAL configuration creation input.  Specify either one or more arcs or else
one continuum.
"""
input StepConfigGcalInput {
  arcs: [GcalArc!]
  continuum: GcalContinuum
  diffuser: GcalDiffuser!
  filter: GcalFilter!
  shutter: GcalShutter!
}

"""
SmartGcal step creation input
"""
input StepConfigSmartGcalInput {

  """
  Smart Gcal type
  """
  smartGcalType: SmartGcalType!
}

"""
Execution state of a recorded step.
"""
enum StepExecutionState {

  "No events have been received since the step was recorded."
  NOT_STARTED

  "Events have been received, but no terminal `Abort`, `EndStep` or `Stop` events."
  ONGOING

  "An event with an 'ABORT' 'StepStage' was received."
  ABORTED

  "An event with an 'END_STEP' 'StepStage' was received."
  COMPLETED

  "An event with a 'STOP' 'StepStage' was received."
  STOPPED

  "An ongoing step was abandoned."
  ABANDONED

}

"""
Step type
"""
enum StepType {
  """
  StepType Bias
  """
  BIAS

  """
  StepType Dark
  """
  DARK

  """
  StepType Gcal
  """
  GCAL

  """
  StepType Science
  """
  SCIENCE

  """
  StepType SmartGcal
  """
  SMART_GCAL
}

type Subscription {
  """

  Subscribes to an event that is generated whenever a(n) observation is
  created or updated.  If a(n) observation id is provided, the event is only
  generated for edits to that particular observation.  If a program id is
  provided then the event must correspond to a(n) observation referenced by
  that program.

  """
  observationEdit(
    input: ObservationEditInput
  ): ObservationEdit!

  """

  Subscribes to an event that is generated whenever a program is created
  or edited. A particular program id may be provided to limit events to
  that program.

  """
  programEdit(
    input: ProgramEditInput
  ): ProgramEdit!

  """

  Subscribes to an event that is generated whenever a(n) target is
  created or updated.  If a(n) target id is provided, the event is only
  generated for edits to that particular target.  If a program id is
  provided then the event must correspond to a(n) target referenced by
  that program.

  """
  targetEdit(
    input: TargetEditInput
  ): TargetEdit!

  """

  Subscribes to an event that is generated whenever a group is
  created or updated.  If a group id is provided, the event is only
  generated for edits to that particular group.  If a program id is
  provided then the event must correspond to a group referenced by
  that program.

  """
  groupEdit(
    input: GroupEditInput
  ): GroupEdit!

  configurationRequestEdit(
    input: ConfigurationRequestEditInput
  ): ConfigurationRequestEdit!
}

input TargetEditInput {
    """
    Target ID
    """
    targetId: TargetId

    """
    Program ID
    """
    programId: ProgramId

}

input GroupEditInput {
    """
    Group ID, or Null to watch top-level group(s), or omit to watch all groups.
    """
    groupId: GroupId

    """
    Program ID
    """
    programId: ProgramId

}

input ConfigurationRequestEditInput {
  
    """
    Program ID
    """
    programId: ProgramId

}

input ObservationEditInput {
  observationId: ObservationId

  programId: ProgramId
}

input ProgramEditInput {
  programId: ProgramId
}

"""
Event sent when a new object is created or updated
"""
type TargetEdit {
  """
  Type of edit
  """
  editType: EditType!

  targetId: TargetId!

  """
  Edited object
  """
  value: Target
}

"""
Event sent when a group is created or updated
"""
type GroupEdit {
  """
  Type of edit
  """
  editType: EditType!

  "Assocated program"
  program: Program!

  """
  Edited group, or null if it's the top-level group.
  """
  value: Group
  id: Long! @deprecated(reason: "id is no longer computed; a constant value is returned")
}

"""
Target environment editing and creation parameters
"""
input TargetEnvironmentInput {
  """
  The explicitBase field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  explicitBase: CoordinatesInput
  asterism: [TargetId!]
}

"""
Target properties
"""
input TargetPropertiesInput {
  name: NonEmptyString
  sidereal: SiderealInput
  nonsidereal: NonsiderealInput
  sourceProfile: SourceProfileInput
  existence: Existence
}

type TelescopeConfig {
  """
  Offset
  """
  offset: Offset!

  """
  Guide State (whether guiding is enabled for this step)
  """
  guiding: GuideState!
}

"""
Science step creation input
"""
input TelescopeConfigInput {
  """
  Offset position, which defaults to (0, 0) arcsec.
  """
  offset: OffsetInput

  """
  Whether guiding is enabled for this step (defaults to 'ENABLED').
  """
  guiding: GuideState
}

"""
Time Accounting Categories.  Each successful proposal is given one or more
time allocations and each allocation has a time accounting category.
"""
enum TimeAccountingCategory {
  "Argentina"                AR
  "Brazil"                   BR
  "Canada"                   CA
  "CFHT Exchange"            CFHT
  "Chile"                    CL
  "Director's Time"          DD
  "Demo Science"             DS
  "Guaranteed Time"          GT
  "Subaru"                   JP
  "Keck Exchange"            KECK
  "Republic of Korea"        KR
  "Large Program"            LP
  "Limited-term Participant" LTP
  "System Verification"      SV
  "University of Hawaii"     UH
  "United States"            US
}

"""
Timing window repetition parameters.
"""
input TimingWindowRepeatInput {
  """
  Repeat period, counting from the start of the window.
  """
  period: TimeSpanInput!

  """
  Repetition times. If omitted, will repeat forever.
  """
  times: PosInt
}

"""
Timing window end parameters.
"""
input TimingWindowEndInput {
  """
  Window end date and time, in UTC. If specified, after and repeat must be omitted.
  """
  atUtc: Timestamp

  """
  Window end after a period of time. If specified, atUtc must be omitted.
  """
  after: TimeSpanInput

  """
  Repetition parameters. Only allowed if after is specified. If ommitted, window will not repeat.
  """
  repeat: TimingWindowRepeatInput
}

"""
Timing window creation parameters.
"""
input TimingWindowInput {
  """
  Whether this is an INCLUDE or EXCLUDE window.
  """
  inclusion: TimingWindowInclusion!

  """
  Window start time, in UTC.
  """
  startUtc: Timestamp!

  """
  Window end parameters. If omitted, the window will never end.
  """
  end: TimingWindowEndInput
}

"""
Un-normalized SED input parameters.  Define one value only.
"""
input UnnormalizedSedInput {
  stellarLibrary: StellarLibrarySpectrum
  coolStar: CoolStarTemperature
  galaxy: GalaxySpectrum
  planet: PlanetSpectrum
  quasar: QuasarSpectrum
  hiiRegion: HiiRegionSpectrum
  planetaryNebula: PlanetaryNebulaSpectrum
  powerLaw: BigDecimal
  blackBodyTempK: PosInt
  fluxDensities: [FluxDensity!]
}

"""
Input for bulk updating multiple observations.  Select observations
with the 'WHERE' input and specify the changes in 'SET'.  All the selected
observations must be in the same program.
"""
input UpdateAsterismsInput {
  """
  Describes the values to modify.
  """
  SET: EditAsterismsPatchInput!

  """
  Filters the observations to be updated according to those that match the
  given constraints.  All must correspond to the same program.
  """
  WHERE: WhereObservation

  """
  Caps the number of results returned to the given value (if additional
  observations match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt

  includeDeleted: Boolean = false
}

"""
The result of updating the selected observations, up to `LIMIT` or the maximum
of (1000).  If `hasMore` is true, additional observations were modified and not
included here.
"""
type UpdateAsterismsResult {
  """
  The edited observations, up to the specified LIMIT or the default maximum of 1000.
  """
  observations: [Observation!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}

"""
Attachment selection and update description.  Use `SET` to specify the changes, `WHERE` to select the attachments to update, and `LIMIT` to control the size of the return value.
"""
input UpdateAttachmentsInput {
  """
  Describes the attachment values to modify.
  """
  SET: AttachmentPropertiesInput!

  """
  Filters the attachments to be updated according to those that match the given constraints.
  """
  WHERE: WhereAttachment

  """
  Caps the number of results returned to the given value (if additional attachments match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt
}

"""
The result of updating the selected attachments, up to `LIMIT` or the maximum of (1000).  If `hasMore` is true, additional attachments were modified and not included here.
"""
type UpdateAttachmentsResult {
  """
  The edited attachments, up to the specified LIMIT or the default maximum of 1000.
  """
  attachments: [Attachment!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}

"""
Call for proposals selection and update description.  Use `SET` to specify the
changes, `WHERE` to select the calls to update, and `LIMIT` to control the
size of the return value.
"""
input UpdateCallsForProposalsInput {

  "Describes the call for proposals properties to modify."
  SET: CallForProposalsPropertiesInput!

  """
  Filters the calls to be updated according to those that match the given
  constraints.
  """
  WHERE: WhereCallForProposals

  """
  Caps the number of results returned to the given value (if additional calls
  match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt

  "Set to `true` to include deleted calls."
  includeDeleted: Boolean = false
}

"""
The result of updating the selected calls for proposals, up to `LIMIT` or the
maximum of 1000.  If `hasMore` is true, additional calls were modified and not
included here.
"""
type UpdateCallsForProposalsResult {
  """
  The edited observations, up to the specified LIMIT or the default maximum of
  1000.
  """
  callsForProposals: [CallForProposals!]!

  "`true` when there were additional edits that were not returned."
  hasMore: Boolean!
}

"""
Dataset selection and update description. Use `SET` to specify the changes, `WHERE` to select the datasets to update, and `LIMIT` to control the size of the return value.
"""
input UpdateDatasetsInput {
  """
  Describes the dataset values to modify.
  """
  SET: DatasetPropertiesInput!

  """
  Filters the datasets to be updated according to those that match the given constraints.
  """
  WHERE: WhereDataset

  """
  Caps the number of results returned to the given value (if additional datasets match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt
}

"""
The result of updating the selected datasets, up to `LIMIT` or the maximum of (1000).  If `hasMore` is true, additional datasets were modified and not included here.
"""
type UpdateDatasetsResult {
  """
  The edited datasets, up to the specified LIMIT or the default maximum of 1000.
  """
  datasets: [Dataset!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}

"""
Dataset selection and update description. Use `SET` to specify the changes, `WHERE` to select the groups to update, and `LIMIT` to control the size of the return value.
"""
input UpdateGroupsInput {
  """
  Describes the dataset values to modify.
  """
  SET: GroupPropertiesInput!

  """
  Filters the datasets to be updated according to those that match the given constraints.
  """
  WHERE: WhereGroup

  """
  Caps the number of results returned to the given value (if additional datasets match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt
}

type UpdateGroupsResult {
  """
  The edited groups, up to the specified LIMIT or the default maximum of 1000.
  """
  groups: [Group!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}

"""
Observation selection and update description.  Use `SET` to specify the changes, `WHERE` to select the observations to update, and `LIMIT` to control the size of the return value.
"""
input UpdateObservationsInput {

  """
  Describes the observation values to modify.
  """
  SET: ObservationPropertiesInput!

  """
  Filters the observations to be updated according to those that match the given constraints.
  """
  WHERE: WhereObservation

  """
  Caps the number of results returned to the given value (if additional observations match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt

  """
  Set to `true` to include deleted observations.
  """
  includeDeleted: Boolean = false
}

"""
ConfigurationRequest selection and update description.  Use `SET` to specify the changes, `WHERE` to select the requests to update, and `LIMIT` to control the size of the return value.
"""
input UpdateConfigurationRequestsInput {

  """
  Describes the observation values to modify.
  """
  SET: ConfigurationRequestProperties!

  """
  Filters the observations to be updated according to those that match the given constraints.
  """
  WHERE: WhereConfigurationRequest

  """
  Caps the number of results returned to the given value (if additional observations match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt

}

"""
Observation selection and times update description.  Use `SET` to specify the changes, `WHERE` to select the observations to update, and `LIMIT` to control the size of the return value.
"""
input UpdateObservationsTimesInput {

  """
  Describes the observation time values to modify.
  """
  SET: ObservationTimesInput!

  """
  Filters the observations to be updated according to those that match the given constraints.
  """
  WHERE: WhereObservation

  """
  Caps the number of results returned to the given value (if additional observations match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt

  """
  Set to `true` to include deleted observations.
  """
  includeDeleted: Boolean = false
}

"""
The result of updating the selected observations, up to `LIMIT` or the maximum of (1000).  If `hasMore` is true, additional observations were modified and not included here.
"""
type UpdateObservationsResult {
  """
  The edited observations, up to the specified LIMIT or the default maximum of 1000.
  """
  observations: [Observation!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}

"""
The result of updating the selected observations, up to `LIMIT` or the maximum of (1000).  If `hasMore` is true, additional observations were modified and not included here.
"""
type UpdateConfigurationRequestsResult {
  """
  The edited observations, up to the specified LIMIT or the default maximum of 1000.
  """
  requests: [ConfigurationRequest!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}



"""
Parameters for the 'updateProgramUsers' mutation.  Use 'SET' to specify the
changes, 'WHERE' to select the program users to update, and 'LIMIT' to control
the size of the return value.
"""
input UpdateProgramUsersInput {

  "Defines the program user properties to modify."
  SET: ProgramUserPropertiesInput!

  "Filters the program users according to those that match the given constraints."
  WHERE: WhereProgramUser

  """
  Caps the number of results returned to the given value (if additional program
  users match the 'WHERE' clause they will be updated not returned).
  """
  LIMIT: NonNegInt

}

"""
The result of calling 'updateProgramUsers', up to 'LIMIT' or the maximum of
1000.  If 'hasMore' is true, additional program users were modified but not
included in the result.
"""
type UpdateProgramUsersResult {

  """
  The first program users that were updated (up to the LIMIT specified in the
  mutation).
  """
  programUsers: [ProgramUser!]!

  "Whether there were additional updated program users that were not returned."
  hasMore: Boolean!
}

"""
Program selection and update description.  Use `SET` to specify the changes, `WHERE` to select the programs to update, and `LIMIT` to control the size of the return value.
"""
input UpdateProgramsInput {
  """
  Describes the program values to modify.
  """
  SET: ProgramPropertiesInput!

  """
  Filters the programs to be updated according to those that match the given constraints.
  """
  WHERE: WhereProgram

  """
  Caps the number of results returned to the given value (if additional programs match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt

  """
  Set to `true` to include deleted programs.
  """
  includeDeleted: Boolean = false
}

"""
The result of updating the selected programs, up to `LIMIT` or the maximum of (1000).  If `hasMore` is true, additional programs were modified and not included here.
"""
type UpdateProgramsResult {
  """
  The edited programs, up to the specified LIMIT or the default maximum of 1000.
  """
  programs: [Program!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}

"""
Input for updating a proposal.  Identify the program to update with one
of `programId`, `proposalReference` or `programReference`.  If more than one of
these is specified, all must match.  Use `SET` to specify the new program
reference properties.
"""
input UpdateProposalInput {
  programId:         ProgramId
  proposalReference: ProposalReferenceLabel
  programReference:  ProgramReferenceLabel
  SET:               ProposalPropertiesInput!
}

"""
The result of updating a proposal
"""
type UpdateProposalResult {
  """
  The updated proposal.
  """
  proposal: Proposal!
}

"""
Target selection and update description. Use `SET` to specify the changes, `WHERE` to select the targets to update, and `LIMIT` to control the size of the return value.
"""
input UpdateTargetsInput {
  """
  Describes the target values to modify.
  """
  SET: TargetPropertiesInput!

  """
  Filters the targets to be updated according to those that match the given constraints.
  """
  WHERE: WhereTarget

  """
  Caps the number of results returned to the given value (if additional targets match the WHERE clause they will be updated but not returned).
  """
  LIMIT: NonNegInt

  """
  Set to `true` to include deleted targets
  """
  includeDeleted: Boolean = false
}

"""
The result of updating the selected targets, up to `LIMIT` or the maximum of (1000).  If `hasMore` is true, additional targets were modified and not included here.
"""
type UpdateTargetsResult {
  """
  The edited targets, up to the specified LIMIT or the default maximum of 1000.
  """
  targets: [Target!]!

  """
  `true` when there were additional edits that were not returned.
  """
  hasMore: Boolean!
}

"""
Wavelength, choose one of the available units
"""
input WavelengthInput {
  picometers: PosInt
  angstroms: PosBigDecimal
  nanometers: PosBigDecimal
  micrometers: PosBigDecimal
}

"""
WavelengthDither, choose one of the available units
"""
input WavelengthDitherInput {
  picometers: Int
  angstroms: BigDecimal
  nanometers: BigDecimal
  micrometers: BigDecimal
}

type OffsetP {
  """
  p offset in µas
  """
  microarcseconds: Long!

  """
  p offset in mas
  """
  milliarcseconds: BigDecimal!

  """
  p offset in arcsec
  """
  arcseconds: BigDecimal!
}

type AirMassRange {
  """
  Minimum AirMass (unitless)
  """
  min: PosBigDecimal!

  """
  Maximum AirMass (unitless)
  """
  max: PosBigDecimal!
}

type Angle {
  """
  Angle in µas
  """
  microarcseconds: Long!

  """
  Angle in µs
  """
  microseconds: BigDecimal!

  """
  Angle in mas
  """
  milliarcseconds: BigDecimal!

  """
  Angle in ms
  """
  milliseconds: BigDecimal!

  """
  Angle in asec
  """
  arcseconds: BigDecimal!

  """
  Angle in sec
  """
  seconds: BigDecimal!

  """
  Angle in amin
  """
  arcminutes: BigDecimal!

  """
  Angle in min
  """
  minutes: BigDecimal!

  """
  Angle in deg
  """
  degrees: BigDecimal!

  """
  Angle in hrs
  """
  hours: BigDecimal!

  """
  Angle in HH:MM:SS
  """
  hms: String!

  """
  Angle in DD:MM:SS
  """
  dms: String!
}

type AsterismGroup {

  program: Program!

  """
  Observations associated with the common value
  """
  observations(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ObservationSelectResult!

  """
  Commonly held value across the observations
  """
  asterism: [Target!]!
}

"""
The matching asterismGroup results, limited to a maximum of 1000 entries.
"""
type AsterismGroupSelectResult {
  """
  Matching asterismGroups up to the return size limit of 1000
  """
  matches: [AsterismGroup!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
AttachmentId id formatted as `a-[1-9a-f][0-9a-f]*`
"""
scalar AttachmentId

"""
Attachment Types
"""
enum AttachmentType {
  """
  A proposal attachment for the science case & design
  """
  SCIENCE

  """
  A proposal attachment for team info, previous use, etc.
  """
  TEAM

  """
  An observation attachment for finder charts
  """
  FINDER

  """
  An observation attachment for MOS masks
  """
  MOS_MASK

  """
  An observation attachment for pre-imaging
  """
  PRE_IMAGING

  """
  A target attachment for custom SEDs
  """
  CUSTOM_SED
}

"""
Attachment
"""
type Attachment {
  id:             AttachmentId!
  attachmentType: AttachmentType!
  fileName:       NonEmptyString!
  description:    NonEmptyString
  checked:        Boolean!
  fileSize:       Long!
  updatedAt:      Timestamp!
  program:        Program!
}

input AttachmentPropertiesInput {
  """
  The description field may be unset by assigning a null value, or ignored by skipping it altogether
  """
  description: NonEmptyString

  """
  The checked status can be set, or ignored by skipping it altogether
  """
  checked: Boolean
}

"""
Brightness bands
"""
enum Band {
  """
  Band SloanU
  """
  SLOAN_U

  """
  Band SloanG
  """
  SLOAN_G

  """
  Band SloanR
  """
  SLOAN_R

  """
  Band SloanI
  """
  SLOAN_I

  """
  Band SloanZ
  """
  SLOAN_Z

  """
  Band U
  """
  U

  """
  Band B
  """
  B

  """
  Band V
  """
  V

  """
  Band R
  """
  R

  """
  Band I
  """
  I

  """
  Band Y
  """
  Y

  """
  Band J
  """
  J

  """
  Band H
  """
  H

  """
  Band K
  """
  K

  """
  Band L
  """
  L

  """
  Band M
  """
  M

  """
  Band N
  """
  N

  """
  Band Q
  """
  Q

  """
  Band Ap
  """
  AP

  """
  Band Gaia
  """
  GAIA

  """
  Band GaiaBP
  """
  GAIA_BP

  """
  Band GaiaRP
  """
  GAIA_RP
}

type BandBrightnessIntegrated {
  """
  Magnitude band
  """
  band: Band!
  value: BigDecimal!
  units: BrightnessIntegratedUnits!

  """
  Error, if any
  """
  error: BigDecimal
}

type BandBrightnessSurface {
  """
  Magnitude band
  """
  band: Band!
  value: BigDecimal!
  units: BrightnessSurfaceUnits!

  """
  Error, if any
  """
  error: BigDecimal
}

"""
Band normalized common interface
"""
interface BandNormalized {
  """
  Un-normalized spectral energy distribution
  """
  sed: UnnormalizedSed
}

type BandNormalizedIntegrated implements BandNormalized {
  brightnesses: [BandBrightnessIntegrated!]!

  """
  Un-normalized spectral energy distribution
  """
  sed: UnnormalizedSed
}

type BandNormalizedSurface implements BandNormalized {
  brightnesses: [BandBrightnessSurface!]!

  """
  Un-normalized spectral energy distribution
  """
  sed: UnnormalizedSed
}

"""
Brightness integrated units
"""
enum BrightnessIntegratedUnits {
  """
  Vega mag
  """
  VEGA_MAGNITUDE

  """
  AB mag
  """
  AB_MAGNITUDE

  """
  Jy
  """
  JANSKY

  """
  W/m²/µm
  """
  W_PER_M_SQUARED_PER_UM

  """
  erg/s/cm²/Å
  """
  ERG_PER_S_PER_CM_SQUARED_PER_A

  """
  erg/s/cm²/Hz
  """
  ERG_PER_S_PER_CM_SQUARED_PER_HZ
}

"""
Brightness surface units
"""
enum BrightnessSurfaceUnits {
  """
  Vega mag/arcsec²
  """
  VEGA_MAG_PER_ARCSEC_SQUARED

  """
  AB mag/arcsec²
  """
  AB_MAG_PER_ARCSEC_SQUARED

  """
  Jy/arcsec²
  """
  JY_PER_ARCSEC_SQUARED

  """
  W/m²/µm/arcsec²
  """
  W_PER_M_SQUARED_PER_UM_PER_ARCSEC_SQUARED

  """
  erg/s/cm²/Å/arcsec²
  """
  ERG_PER_S_PER_CM_SQUARED_PER_A_PER_ARCSEC_SQUARED

  """
  erg/s/cm²/Hz/arcsec²
  """
  ERG_PER_S_PER_CM_SQUARED_PER_HZ_PER_ARCSEC_SQUARED
}

type CatalogInfo {
  """
  Catalog name option
  """
  name: CatalogName!

  """
  Catalog id string
  """
  id: String!

  """
  Catalog description of object morphology
  """
  objectType: String
}

"""
Catalog name values
"""
enum CatalogName {
  """
  CatalogName Simbad
  """
  SIMBAD

  """
  CatalogName Import
  """
  IMPORT

  """
  CatalogName Gaia
  """
  GAIA
}

"""
Who is charged for time, if anyone.
"""
enum ChargeClass {

  """
  Time that is not charged.
  """
  NON_CHARGED

  """
  Time charged to a partner country / entity.
  """
  PARTNER

  """
  Time charged to the science program.
  """
  PROGRAM

}

"""
Cloud extinction
"""
enum CloudExtinction {
  """
  CloudExtinction PointOne
  """
  POINT_ONE

  """
  CloudExtinction PointThree
  """
  POINT_THREE

  """
  CloudExtinction PointFive
  """
  POINT_FIVE

  """
  CloudExtinction OnePointZero
  """
  ONE_POINT_ZERO

  """
  CloudExtinction OnePointFive
  """
  ONE_POINT_FIVE

  """
  CloudExtinction TwoPointZero
  """
  TWO_POINT_ZERO

  """
  CloudExtinction ThreePointZero
  """
  THREE_POINT_ZERO
}

"""
ObservingMode
"""
enum ObservingModeType {

  """
  ObservingModeType GmosNorthLongSlit
  """
  GMOS_NORTH_LONG_SLIT

  """
  ObservingModeType GmosSouthLongSlit
  """
  GMOS_SOUTH_LONG_SLIT

}

type ConstraintSet {
  """
  Image quality
  """
  imageQuality: ImageQuality!

  """
  Cloud extinction
  """
  cloudExtinction: CloudExtinction!

  """
  Sky background
  """
  skyBackground: SkyBackground!

  """
  Water vapor
  """
  waterVapor: WaterVapor!

  """
  Either air mass range or elevation range
  """
  elevationRange: ElevationRange!
}

type ConstraintSetGroup {

  """
  Observations associated with the common value
  """
  observations(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ObservationSelectResult!

  """
  Commonly held value across the observations
  """
  constraintSet: ConstraintSet!

  """
  Link back to program.
  """
  program: Program!
}

"""
The matching constraintSetGroup results, limited to a maximum of 1000 entries.
"""
type ConstraintSetGroupSelectResult {
  """
  Matching constraintSetGroups up to the return size limit of 1000
  """
  matches: [ConstraintSetGroup!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
Cool star temperature options
"""
enum CoolStarTemperature {
  """
  400 K
  """
  T400_K

  """
  600 K
  """
  T600_K

  """
  800 K
  """
  T800_K

  """
  900 K
  """
  T900_K

  """
  1000 K
  """
  T1000_K

  """
  1200 K
  """
  T1200_K

  """
  1400 K
  """
  T1400_K

  """
  1600 K
  """
  T1600_K

  """
  1800 K
  """
  T1800_K

  """
  2000 K
  """
  T2000_K

  """
  2200 K
  """
  T2200_K

  """
  2400 K
  """
  T2400_K

  """
  2600 K
  """
  T2600_K

  """
  2800 K
  """
  T2800_K
}

type Coordinates {
  """
  Right Ascension
  """
  ra: RightAscension!

  """
  Declination
  """
  dec: Declination!
}

"DatasetId id formatted as `d-[1-9a-f][0-9a-f]*`"
scalar DatasetId

type Dataset {

  "Dataset id."
  id: DatasetId!

  "The corresponding step."
  step: StepRecord!

  "Exposure index within the step."
  index: PosInt!

  "Dataset reference, assuming the observation has an observation reference."
  reference: DatasetReference

  "Observation associated with this dataset."
  observation: Observation!

  "Visit associated with this dataset."
  visit: Visit!

  "Events associated with the dataset."
  events(
    "Starts the result set at (or after if not existent) the given execution event id."
    OFFSET: ExecutionEventId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): ExecutionEventSelectResult!

  "Dataset filename."
  filename: DatasetFilename!

  "Dataset QA state, if any has been set."
  qaState: DatasetQaState

  "Dataset comment, if any has been set."
  comment: NonEmptyString

  "Dataset time interval, if the dataset collection has started."
  interval: TimestampInterval

}

"""
Dataset-level events.  A single dataset will be associated with multiple events
as it makes its way through observe, readout and write stages.
"""
type DatasetEvent implements ExecutionEvent {

  "Event id."
  id: ExecutionEventId!

  "Visit associated with this event."
  visit: Visit!

  "Observation whose execution produced this event."
  observation: Observation!

  "Time at which this event was received."
  received: Timestamp!

  "Event type."
  eventType: ExecutionEventType!

  "Atom associated with this event."
  atom: AtomRecord!

  "The associated step."
  step: StepRecord!

  "Dataset execution stage."
  datasetStage: DatasetStage!

  "The associated dataset."
  dataset: Dataset!

}

"Dataset filename in standard format."
scalar DatasetFilename

"""
Dataset QA State
"""
enum DatasetQaState {
  """
  DatasetQaState Pass
  """
  PASS

  """
  DatasetQaState Usable
  """
  USABLE

  """
  DatasetQaState Fail
  """
  FAIL
}

"""
Dataset reference type, broken into its constituient parts and including
a formatted label.
"""
type DatasetReference {

  "Formatted dataset reference label."
  label: DatasetReferenceLabel!

  "The observation reference."
  observation: ObservationReference!

  "The step index relative to its observation."
  stepIndex: PosInt!

  "The exposure index relative to its step."
  exposureIndex: PosInt!
}

"""
Dataset reference, formatted according to the observation, suffixed with
the step and exposure indices. For example, G-2024B-1234-Q-0001-0002-0003 where
G-2024B-1234-Q-0001 is the observation reference label, 2 is the step index and
3 is the exposure index.
"""
scalar DatasetReferenceLabel

"""
The matching dataset results, limited to a maximum of 1000 entries.
"""
type DatasetSelectResult {
  """
  Matching datasets up to the return size limit of 1000
  """
  matches: [Dataset!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"Execution stage or phase of an individual dataset."
enum DatasetStage {

  END_EXPOSE

  END_READOUT

  END_WRITE

  START_EXPOSE

  START_READOUT

  START_WRITE
}

type Declination {
  """
  Declination in DD:MM:SS.SS format
  """
  dms: DmsString!

  """
  Declination in signed degrees
  """
  degrees: BigDecimal!

  """
  Declination in signed µas
  """
  microarcseconds: Long!
}

"""
Target declination coordinate in format '[+/-]DD:MM:SS.sss'
"""
scalar DmsString

"""
Educational Status Phd/Grad/Undergrad/Other
"""
enum EducationalStatus {
  """
  Educational Status PhD
  """
  PHD

  """
  Educational Status Grad Student
  """
  GRAD_STUDENT

  """
  Educational Status Undergrad Student
  """
  UNDERGRAD_STUDENT

  """
  Educational Status Other
  """
  OTHER
}

"""
Either air mass range or elevation range
"""
type ElevationRange {
  """
  AirMass range if elevation range is an Airmass range
  """
  airMass: AirMassRange

  """
  Hour angle range if elevation range is an Hour angle range
  """
  hourAngle: HourAngleRange
}

type EmissionLineIntegrated {
  wavelength: Wavelength!

  """
  km/s
  """
  lineWidth: PosBigDecimal!
  lineFlux: LineFluxIntegrated!
}

type EmissionLineSurface {
  wavelength: Wavelength!

  """
  km/s
  """
  lineWidth: PosBigDecimal!
  lineFlux: LineFluxSurface!
}

type EmissionLinesIntegrated {
  lines: [EmissionLineIntegrated!]!
  fluxDensityContinuum: FluxDensityContinuumIntegrated!
}

type EmissionLinesSurface {
  lines: [EmissionLineSurface!]!
  fluxDensityContinuum: FluxDensityContinuumSurface!
}

"""
Ephemeris key type options
"""
enum EphemerisKeyType {
  """
  EphemerisKeyType Comet
  """
  COMET

  """
  EphemerisKeyType AsteroidNew
  """
  ASTEROID_NEW

  """
  EphemerisKeyType AsteroidOld
  """
  ASTEROID_OLD

  """
  EphemerisKeyType MajorBody
  """
  MAJOR_BODY

  """
  EphemerisKeyType UserSupplied
  """
  USER_SUPPLIED
}

"""
Reference observation epoch in format '[JB]YYYY.YYY'
"""
scalar EpochString

type Execution {

  """
  Calculations dependent on the sequence, such as planned time and offsets.
  If a sequence cannot be generated for this observation, `null` is returned
  along with warning messages.
  """
  digest: ExecutionDigest

  """
  Full execution config, including acquisition and science sequences.  If a
  sequence cannot be generated for this observation, `null` is returned along
  with warning messages.
  """
  config(

    """
    The maximum size (number of atoms) of the `possibleFuture` in the sequences.
    If the projected future is longer, the size will be capped at this value.
    Use 0 if only interested in the `nextAtom`.  The maximum is 100.  Each
    sequence has a `hasMore` field that can be used to determine whether there
    additional atoms beyond those returned in `possibleFuture`.  The total
    projected atom count is available in the execution digest.
    """
    futureLimit: NonNegInt = 25

  ): ExecutionConfig

  """
  Determines the execution state as a whole of this observation.
  """
  executionState: ExecutionState!

  "Executed (or at least partially executed) atom records, across all visits."
  atomRecords(
    "Starts the result set at the given atom creation time."
    OFFSET: Timestamp

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): AtomRecordSelectResult!

  "Datasets associated with the observation, across all visits."
  datasets(
    "Starts the result set at (or after if not existent) the given dataset id."
    OFFSET: DatasetId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): DatasetSelectResult!

  "Events associated with the observation, across all visits."
  events(
    "Starts the result set at (or after if not existent) the given execution event id."
    OFFSET: ExecutionEventId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): ExecutionEventSelectResult!

  "Visits associated with the observation."
  visits(
    "Starts the result set at (or after if not existent) the given visit id."
    OFFSET: VisitId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): VisitSelectResult!

  "Time accounting calculation for this observation."
  timeCharge: CategorizedTime!
}

"""
Execution configuration.  All but one of the instruments will be `null`.
"""
type ExecutionConfig {

  """
  Instrument type.  This will indicate which of the instrument-specific fields
  is defined.
  """
  instrument: Instrument!

  """
  GMOS North execution config.  This will be null unless the `instrument` is
  `GMOS_NORTH`.
  """
  gmosNorth: GmosNorthExecutionConfig

  """
  GMOS South execution config.  This will be null unless the `instrument` is
  `GMOS_SOUTH`.
  """
  gmosSouth: GmosSouthExecutionConfig

}

"""
Execution event (sequence, step, or dataset events)
"""
interface ExecutionEvent {
  "Event id."
  id: ExecutionEventId!

  "Visit associated with the event."
  visit: Visit!

  "Observation whose execution produced this event."
  observation: Observation!

  "Time at which this event was received."
  received: Timestamp!

  "Event type."
  eventType: ExecutionEventType!
}

"""
ExecutionEventId id formatted as `e-[1-9a-f][0-9a-f]*`
"""
scalar ExecutionEventId

"""
The matching ExecutionEvent results, limited to a maximum of 1000 entries.
"""
type ExecutionEventSelectResult {
  """
  Matching ExecutionEvents up to the return size limit of 1000
  """
  matches: [ExecutionEvent!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
State of being: either Deleted or Present
"""
enum Existence {
  """
  Existence Present
  """
  PRESENT

  """
  Existence Deleted
  """
  DELETED
}

"Summarizes the execution setup time and sequences."
type ExecutionDigest {

  "Setup time calculations."
  setup:       SetupTime!

  "Acquisition sequence summary."
  acquisition: SequenceDigest

  "Science sequence summary."
  science:     SequenceDigest

}


"""
Exposure time mode, either signal to noise or fixed
"""
type ExposureTimeMode {
  """
  Signal to noise exposure time mode data, if applicable
  """
  signalToNoise: SignalToNoiseMode

  """
  Fixed exposure time mode data, if applicable
  """
  fixedExposure: FixedExposureMode
}

"""
Metadata for `enum FilterType`
"""
type FilterTypeMeta {
  tag:        FilterType!
  shortName:  String!
  longName:       String!
}

"""
Fixed exposure time mode
"""
type FixedExposureMode {
  """
  Exposure count
  """
  count: NonNegInt!

  """
  Exposure time
  """
  time: TimeSpan!
}

type FluxDensityContinuumIntegrated {
  value: PosBigDecimal!
  units: FluxDensityContinuumIntegratedUnits!
  error: PosBigDecimal
}

"""
Flux density continuum integrated units
"""
enum FluxDensityContinuumIntegratedUnits {
  """
  W/m²/µm
  """
  W_PER_M_SQUARED_PER_UM

  """
  erg/s/cm²/Å
  """
  ERG_PER_S_PER_CM_SQUARED_PER_A
}

type FluxDensityContinuumSurface {
  value: PosBigDecimal!
  units: FluxDensityContinuumSurfaceUnits!
  error: PosBigDecimal
}

"""
Flux density continuum surface units
"""
enum FluxDensityContinuumSurfaceUnits {
  """
  W/m²/µm/arcsec²
  """
  W_PER_M_SQUARED_PER_UM_PER_ARCSEC_SQUARED

  """
  erg/s/cm²/Å/arcsec²
  """
  ERG_PER_S_PER_CM_SQUARED_PER_A_PER_ARCSEC_SQUARED
}

type FluxDensityEntry {
  wavelength: Wavelength!
  density: PosBigDecimal!
}

"""
Focal plane Single/Multi/IFU
"""
enum FocalPlane {
  """
  FocalPlane SingleSlit
  """
  SINGLE_SLIT

  """
  FocalPlane MultipleSlit
  """
  MULTIPLE_SLIT

  """
  FocalPlane IFU
  """
  IFU
}

"""
Galaxy spectrum
"""
enum GalaxySpectrum {
  """
  GalaxySpectrum Elliptical
  """
  ELLIPTICAL

  """
  GalaxySpectrum Spiral
  """
  SPIRAL
}

"""
Gaussian source, one of bandNormalized and emissionLines will be defined.
"""
type GaussianSource {
  """
  full width at half maximum
  """
  fwhm: Angle!

  """
  Band normalized spectral definition
  """
  bandNormalized: BandNormalizedIntegrated

  """
  Emission lines spectral definition
  """
  emissionLines: EmissionLinesIntegrated
}

"""
Gender Male/Female/Other/NotSpecified
"""
enum Gender {
  """
  Gender Male
  """
  MALE

  """
  Gender Female
  """
  FEMALE

  """
  Gender Other
  """
  OTHER

  """
  Gender Not Specified
  """
  NOT_SPECIFIED
}

"""
GMOS amp gain
"""
enum GmosAmpGain {
  """
  GmosAmpGain Low
  """
  LOW

  """
  GmosAmpGain High
  """
  HIGH
}

"""
GMOS amp read mode
"""
enum GmosAmpReadMode {
  """
  GmosAmpReadMode Slow
  """
  SLOW

  """
  GmosAmpReadMode Fast
  """
  FAST
}

"""
GMOS North FPU
"""
enum GmosNorthBuiltinFpu {
  """
  GmosNorthBuiltinFpu Ns0
  """
  NS0

  """
  GmosNorthBuiltinFpu Ns1
  """
  NS1

  """
  GmosNorthBuiltinFpu Ns2
  """
  NS2

  """
  GmosNorthBuiltinFpu Ns3
  """
  NS3

  """
  GmosNorthBuiltinFpu Ns4
  """
  NS4

  """
  GmosNorthBuiltinFpu Ns5
  """
  NS5

  """
  GmosNorthBuiltinFpu LongSlit_0_25
  """
  LONG_SLIT_0_25

  """
  GmosNorthBuiltinFpu LongSlit_0_50
  """
  LONG_SLIT_0_50

  """
  GmosNorthBuiltinFpu LongSlit_0_75
  """
  LONG_SLIT_0_75

  """
  GmosNorthBuiltinFpu LongSlit_1_00
  """
  LONG_SLIT_1_00

  """
  GmosNorthBuiltinFpu LongSlit_1_50
  """
  LONG_SLIT_1_50

  """
  GmosNorthBuiltinFpu LongSlit_2_00
  """
  LONG_SLIT_2_00

  """
  GmosNorthBuiltinFpu LongSlit_5_00
  """
  LONG_SLIT_5_00

  """
  GmosNorthBuiltinFpu Ifu2Slits
  """
  IFU2_SLITS

  """
  GmosNorthBuiltinFpu IfuBlue
  """
  IFU_BLUE

  """
  GmosNorthBuiltinFpu IfuRed
  """
  IFU_RED
}

"""
GMOS North Filter
"""
enum GmosNorthFilter {
  """
  GmosNorthFilter GPrime
  """
  G_PRIME

  """
  GmosNorthFilter RPrime
  """
  R_PRIME

  """
  GmosNorthFilter IPrime
  """
  I_PRIME

  """
  GmosNorthFilter ZPrime
  """
  Z_PRIME

  """
  GmosNorthFilter Z
  """
  Z

  """
  GmosNorthFilter Y
  """
  Y

  """
  GmosNorthFilter RI
  """
  RI

  """
  GmosNorthFilter GG455
  """
  GG455

  """
  GmosNorthFilter OG515
  """
  OG515

  """
  GmosNorthFilter RG610
  """
  RG610

  """
  GmosNorthFilter CaT
  """
  CA_T

  """
  GmosNorthFilter Ha
  """
  HA

  """
  GmosNorthFilter HaC
  """
  HA_C

  """
  GmosNorthFilter DS920
  """
  DS920

  """
  GmosNorthFilter SII
  """
  SII

  """
  GmosNorthFilter OIII
  """
  OIII

  """
  GmosNorthFilter OIIIC
  """
  OIIIC

  """
  GmosNorthFilter OVI
  """
  OVI

  """
  GmosNorthFilter OVIC
  """
  OVIC

  """
  GmosNorthFilter HeII
  """
  HE_II

  """
  GmosNorthFilter HeIIC
  """
  HE_IIC

  """
  GmosNorthFilter HartmannA_RPrime
  """
  HARTMANN_A_R_PRIME

  """
  GmosNorthFilter HartmannB_RPrime
  """
  HARTMANN_B_R_PRIME

  """
  GmosNorthFilter GPrime_GG455
  """
  G_PRIME_GG455

  """
  GmosNorthFilter GPrime_OG515
  """
  G_PRIME_OG515

  """
  GmosNorthFilter RPrime_RG610
  """
  R_PRIME_RG610

  """
  GmosNorthFilter IPrime_CaT
  """
  I_PRIME_CA_T

  """
  GmosNorthFilter ZPrime_CaT
  """
  Z_PRIME_CA_T

  """
  GmosNorthFilter UPrime
  """
  U_PRIME
}

"""
GMOS North Grating
"""
enum GmosNorthGrating {
  """
  GmosNorthGrating B1200_G5301
  """
  B1200_G5301

  """
  GmosNorthGrating R831_G5302
  """
  R831_G5302

  """
  GmosNorthGrating B600_G5303
  """
  B600_G5303

  """
  GmosNorthGrating B600_G5307
  """
  B600_G5307

  """
  GmosNorthGrating R600_G5304
  """
  R600_G5304

  """
  GmosNorthGrating B480_G5309
  """
  B480_G5309

  """
  GmosNorthGrating R400_G5305
  """
  R400_G5305

  """
  GmosNorthGrating R150_G5306
  """
  R150_G5306

  """
  GmosNorthGrating R150_G5308
  """
  R150_G5308
}

"""
GMOS North Long Slit mode
"""
type GmosNorthLongSlit {

  """
  GMOS North Grating
  """
  grating: GmosNorthGrating!

  """
  GMOS North Filter
  """
  filter: GmosNorthFilter

  """
  GMOS North FPU
  """
  fpu: GmosNorthBuiltinFpu!

  """
  The central wavelength, either explicitly specified in `explicitCentralWavelength`
  or else taken from the `defaultCentralWavelength`.
  """
  centralWavelength: Wavelength!

  """
  GMOS X-Binning, either explicitly specified in explicitXBin or else taken
  from the defaultXBin.
  """
  xBin: GmosXBinning!

  """
  Default GMOS X-Binning, calculated from the effective slit size which in
  turn is based on the selected FPU, target source profile and image quality.
  """
  defaultXBin: GmosXBinning!

  """
  Optional explicitly specified GMOS X-Binning. If set it overrides the
  default.
  """
  explicitXBin: GmosXBinning


  """
  GMOS Y-Binning, either explicitly specified in explicitYBin or else taken
  from the defaultYBin.
  """
  yBin: GmosYBinning!

  """
  Default GMOS Y-Binning (TWO).
  """
  defaultYBin: GmosYBinning!

  """
  Optional explicitly specified GMOS Y-Binning. If set it overrides the
  default.
  """
  explicitYBin: GmosYBinning


  """
  GMOS amp read mode, either explicitly specified in explicitAmpReadMode or
  else taken from the defaultAmpReadMode.
  """
  ampReadMode: GmosAmpReadMode!

  """
  Default GmosAmpReadMode (SLOW).
  """
  defaultAmpReadMode: GmosAmpReadMode!

  """
  Optional explicitly specified GMOS amp read mode. If set it overrides the
  default.
  """
  explicitAmpReadMode: GmosAmpReadMode


  """
  GMOS amp read gain, either explicitly specified in explicitAmpGain or else
  taken from the defaultAmpGain.
  """
  ampGain: GmosAmpGain!

  """
  Default GMOS amp gain (LOW).
  """
  defaultAmpGain: GmosAmpGain!

  """
  Optional explicitly specified GMOS amp gain.  If set it override the default.
  """
  explicitAmpGain: GmosAmpGain


  """
  GMOS ROI, either explicitly specified in explicitRoi or else taken from the
  defaultRoi.
  """
  roi: GmosRoi!

  """
  Default GMOS ROI (FULL_FRAME).
  """
  defaultRoi: GmosRoi!

  """
  Optional explicitly specified GMOS ROI. If set it overrides the default.
  """
  explicitRoi: GmosRoi


  """
  Wavelength dithers required to fill in the chip gaps. This value is either
  explicitly specified in explicitWavelengthDithers or else taken from
  defaultWavelengthDithers
  """
  wavelengthDithers: [WavelengthDither!]!

  """
  Default wavelength dithers, calculated based on the grating dispersion.
  """
  defaultWavelengthDithers: [WavelengthDither!]!

  """
  Optional explicitly specified wavelength dithers.  If set it overrides the
  default.
  """
  explicitWavelengthDithers: [WavelengthDither!]


  """
  Spacial q offsets, either explicitly specified in explicitSpatialOffsets
  or else taken from defaultSpatialOffsets
  """
  spatialOffsets: [OffsetQ!]!

  """
  Default spatial offsets.
  """
  defaultSpatialOffsets: [OffsetQ!]!

  """
  Optional explicitly specified spatial q offsets. If set it overrides the
  the default.
  """
  explicitSpatialOffsets: [OffsetQ!]

  """
  The grating as it was initially selected.  See the `grating` field for the
  grating that will be used in the observation.
  """
  initialGrating: GmosNorthGrating!

  """
  The filter as it was initially selected (if any).  See the `filter` field
  for the filter that will be used in the observation.
  """
  initialFilter: GmosNorthFilter

  """
  The FPU as it was initially selected.  See the `fpu` field for the FPU that
  will be used in the observation.
  """
  initialFpu: GmosNorthBuiltinFpu!

  """
  The central wavelength as initially selected.  See the `centralWavelength`
  field for the wavelength that will be used in the observation.
  """
  initialCentralWavelength: Wavelength!
}

"""
GMOS Region Of Interest
"""
enum GmosRoi {
  """
  GmosRoi FullFrame
  """
  FULL_FRAME

  """
  GmosRoi Ccd2
  """
  CCD2

  """
  GmosRoi CentralSpectrum
  """
  CENTRAL_SPECTRUM

  """
  GmosRoi CentralStamp
  """
  CENTRAL_STAMP

  """
  GmosRoi TopSpectrum
  """
  TOP_SPECTRUM

  """
  GmosRoi BottomSpectrum
  """
  BOTTOM_SPECTRUM

  """
  GmosRoi Custom
  """
  CUSTOM
}

"""
GMOS South FPU
"""
enum GmosSouthBuiltinFpu {
  """
  GmosSouthBuiltinFpu Bhros
  """
  BHROS

  """
  GmosSouthBuiltinFpu Ns1
  """
  NS1

  """
  GmosSouthBuiltinFpu Ns2
  """
  NS2

  """
  GmosSouthBuiltinFpu Ns3
  """
  NS3

  """
  GmosSouthBuiltinFpu Ns4
  """
  NS4

  """
  GmosSouthBuiltinFpu Ns5
  """
  NS5

  """
  GmosSouthBuiltinFpu LongSlit_0_25
  """
  LONG_SLIT_0_25

  """
  GmosSouthBuiltinFpu LongSlit_0_50
  """
  LONG_SLIT_0_50

  """
  GmosSouthBuiltinFpu LongSlit_0_75
  """
  LONG_SLIT_0_75

  """
  GmosSouthBuiltinFpu LongSlit_1_00
  """
  LONG_SLIT_1_00

  """
  GmosSouthBuiltinFpu LongSlit_1_50
  """
  LONG_SLIT_1_50

  """
  GmosSouthBuiltinFpu LongSlit_2_00
  """
  LONG_SLIT_2_00

  """
  GmosSouthBuiltinFpu LongSlit_5_00
  """
  LONG_SLIT_5_00

  """
  GmosSouthBuiltinFpu Ifu2Slits
  """
  IFU2_SLITS

  """
  GmosSouthBuiltinFpu IfuBlue
  """
  IFU_BLUE

  """
  GmosSouthBuiltinFpu IfuRed
  """
  IFU_RED

  """
  GmosSouthBuiltinFpu IfuNS2Slits
  """
  IFU_NS2_SLITS

  """
  GmosSouthBuiltinFpu IfuNSBlue
  """
  IFU_NS_BLUE

  """
  GmosSouthBuiltinFpu IfuNSRed
  """
  IFU_NS_RED
}

"""
GMOS South Filter
"""
enum GmosSouthFilter {
  """
  GmosSouthFilter UPrime
  """
  U_PRIME

  """
  GmosSouthFilter GPrime
  """
  G_PRIME

  """
  GmosSouthFilter RPrime
  """
  R_PRIME

  """
  GmosSouthFilter IPrime
  """
  I_PRIME

  """
  GmosSouthFilter ZPrime
  """
  Z_PRIME

  """
  GmosSouthFilter Z
  """
  Z

  """
  GmosSouthFilter Y
  """
  Y

  """
  GmosSouthFilter GG455
  """
  GG455

  """
  GmosSouthFilter OG515
  """
  OG515

  """
  GmosSouthFilter RG610
  """
  RG610

  """
  GmosSouthFilter RG780
  """
  RG780

  """
  GmosSouthFilter CaT
  """
  CA_T

  """
  GmosSouthFilter HartmannA_RPrime
  """
  HARTMANN_A_R_PRIME

  """
  GmosSouthFilter HartmannB_RPrime
  """
  HARTMANN_B_R_PRIME

  """
  GmosSouthFilter GPrime_GG455
  """
  G_PRIME_GG455

  """
  GmosSouthFilter GPrime_OG515
  """
  G_PRIME_OG515

  """
  GmosSouthFilter RPrime_RG610
  """
  R_PRIME_RG610

  """
  GmosSouthFilter IPrime_RG780
  """
  I_PRIME_RG780

  """
  GmosSouthFilter IPrime_CaT
  """
  I_PRIME_CA_T

  """
  GmosSouthFilter ZPrime_CaT
  """
  Z_PRIME_CA_T

  """
  GmosSouthFilter Ha
  """
  HA

  """
  GmosSouthFilter SII
  """
  SII

  """
  GmosSouthFilter HaC
  """
  HA_C

  """
  GmosSouthFilter OIII
  """
  OIII

  """
  GmosSouthFilter OIIIC
  """
  OIIIC

  """
  GmosSouthFilter OVI
  """
  OVI

  """
  GmosSouthFilter OVIC
  """
  OVIC

  """
  GmosSouthFilter HeII
  """
  HE_II

  """
  GmosSouthFilter HeIIC
  """
  HE_IIC

  """
  GmosSouthFilter Lya395
  """
  LYA395
}

"""
GMOS South Grating
"""
enum GmosSouthGrating {
  """
  GmosSouthGrating B1200_G5321
  """
  B1200_G5321

  """
  GmosSouthGrating R831_G5322
  """
  R831_G5322

  """
  GmosSouthGrating B600_G5323
  """
  B600_G5323

  """
  GmosSouthGrating R600_G5324
  """
  R600_G5324

  """
  GmosSouthGrating B480_G5327
  """
  B480_G5327

  """
  GmosSouthGrating R400_G5325
  """
  R400_G5325

  """
  GmosSouthGrating R150_G5326
  """
  R150_G5326
}

"""
GMOS South Long Slit mode
"""
type GmosSouthLongSlit {

  """
  GMOS South Grating
  """
  grating: GmosSouthGrating!

  """
  GMOS South Filter
  """
  filter: GmosSouthFilter

  """
  GMOS South FPU
  """
  fpu: GmosSouthBuiltinFpu!

  """
  The central wavelength, either explicitly specified in `explicitCentralWavelength`
  or else taken from the `defaultCentralWavelength`.
  """
  centralWavelength: Wavelength!

  """
  GMOS X-Binning, either explicitly specified in explicitXBin or else taken
  from the defaultXBin.
  """
  xBin: GmosXBinning!

  """
  Default GMOS X-Binning, calculated from the effective slit size which in
  turn is based on the selected FPU, target source profile and image quality.
  """
  defaultXBin: GmosXBinning!

  """
  Optional explicitly specified GMOS X-Binning. If set it overrides the
  default.
  """
  explicitXBin: GmosXBinning


  """
  GMOS Y-Binning, either explicitly specified in explicitYBin or else taken
  from the defaultYBin.
  """
  yBin: GmosYBinning!

  """
  Default GMOS Y-Binning (TWO).
  """
  defaultYBin: GmosYBinning!

  """
  Optional explicitly specified GMOS Y-Binning. If set it overrides the
  default.
  """
  explicitYBin: GmosYBinning


  """
  GMOS amp read mode, either explicitly specified in explicitAmpReadMode or
  else taken from the defaultAmpReadMode.
  """
  ampReadMode: GmosAmpReadMode!

  """
  Default GmosAmpReadMode (SLOW).
  """
  defaultAmpReadMode: GmosAmpReadMode!

  """
  Optional explicitly specified GMOS amp read mode. If set it overrides the
  default.
  """
  explicitAmpReadMode: GmosAmpReadMode


  """
  GMOS amp read gain, either explicitly specified in explicitAmpGain or else
  taken from the defaultAmpGain.
  """
  ampGain: GmosAmpGain!

  """
  Default GMOS amp gain (LOW).
  """
  defaultAmpGain: GmosAmpGain!

  """
  Optional explicitly specified GMOS amp gain.  If set it override the default.
  """
  explicitAmpGain: GmosAmpGain


  """
  GMOS ROI, either explicitly specified in explicitRoi or else taken from the
  defaultRoi.
  """
  roi: GmosRoi!

  """
  Default GMOS ROI (FULL_FRAME).
  """
  defaultRoi: GmosRoi!

  """
  Optional explicitly specified GMOS ROI. If set it overrides the default.
  """
  explicitRoi: GmosRoi


  """
  Wavelength dithers required to fill in the chip gaps. This value is either
  explicitly specified in explicitWavelengthDithers or else taken from
  defaultWavelengthDithers
  """
  wavelengthDithers: [WavelengthDither!]!

  """
  Default wavelength dithers, calculated based on the grating dispersion.
  """
  defaultWavelengthDithers: [WavelengthDither!]!

  """
  Optional explicitly specified wavelength dithers.  If set it overrides the
  default.
  """
  explicitWavelengthDithers: [WavelengthDither!]


  """
  Spacial q offsets, either explicitly specified in explicitSpatialOffsets
  or else taken from defaultSpatialOffsets
  """
  spatialOffsets: [OffsetQ!]!

  """
  Default spatial offsets.
  """
  defaultSpatialOffsets: [OffsetQ!]!

  """
  Optional explicitly specified spatial q offsets. If set it overrides the
  the default.
  """
  explicitSpatialOffsets: [OffsetQ!]

  """
  The grating as it was initially selected.  See the `grating` field for the
  grating that will be used in the observation.
  """
  initialGrating: GmosSouthGrating!

  """
  The filter as it was initially selected (if any).  See the `filter` field
  for the filter that will be used in the observation.
  """
  initialFilter: GmosSouthFilter

  """
  The FPU as it was initially selected.  See the `fpu` field for the FPU that
  will be used in the observation.
  """
  initialFpu: GmosSouthBuiltinFpu!

  """
  The central wavelength as initially selected.  See the `centralWavelength`
  field for the wavelength that will be used in the observation.
  """
  initialCentralWavelength: Wavelength!
}

"""
GMOS X Binning
"""
enum GmosXBinning {
  """
  GmosXBinning One
  """
  ONE

  """
  GmosXBinning Two
  """
  TWO

  """
  GmosXBinning Four
  """
  FOUR
}

"""
GMOS Y Binning
"""
enum GmosYBinning {
  """
  GmosYBinning One
  """
  ONE

  """
  GmosYBinning Two
  """
  TWO

  """
  GmosYBinning Four
  """
  FOUR
}

"Gemini Observatory Archive properties for a particular program."
type GoaProperties {

  """
  How many months to withhold public access to the data.  This property is
  applicable to science programs, defaults to the proprietary period associated
  with the Call for Proposals if any; 0 months otherwise.
  """
  proprietaryMonths: NonNegInt!

  """
  Whether the PI wishes to be notified when new data are received. This property
  is applicable to science programs and defaults to true.
  """
  shouldNotify: Boolean!

  """
  Whether the header (as well as the data itself) should remain private.  This
  property is applicable to science programs and defaults to false.
  """
  privateHeader: Boolean!

}

"""
Gemini Observatory Archive properties creation and editing input for a
particular program.
"""
input GoaPropertiesInput {

  """
  How many months to withhold public access to the data.  This property is
  applicable to science programs, defaults to the proprietary period associated
  with the Call for Proposals if any; 0 months otherwise.
  """
  proprietaryMonths: NonNegInt

  """
  Whether the PI wishes to be notified when new data are received. This property
  is applicable to science programs and defaults to true.
  """
  shouldNotify: Boolean

  """
  Whether the header (as well as the data itself) should remain private.  This
  property is applicable to science programs and defaults to false.
  """
  privateHeader: Boolean

}

"A group of observations and other groups."
type Group {

  id: GroupId!

  "Id of this group's parent, or null if this group is at the top level."
  parentId: GroupId

  "Position of this group in its parent group (or at the top level)."
  parentIndex: NonNegShort!

  "The program in which this group is found."
  program: Program!

  "Optionally, a name"
  name: NonEmptyString

  "Optionally, a description."
  description: NonEmptyString

  "How many do we need to complete? If this is null then it means we have to complete them all"
  minimumRequired: NonNegShort

  "Do they need to be completed in order?"
  ordered: Boolean!

  "Is there a minimum required and/or maximum allowed timespan between observations?"
  minimumInterval: TimeSpan
  maximumInterval: TimeSpan

  "Contained elements"
  elements(includeDeleted: Boolean! = false): [GroupElement!]!

  """
  Remaining execution time estimate range, assuming it can be calculated.  In
  order for an observation to have an estimate, it must be fully defined such
  that a sequence can be generated for it.  If a group has observations that
  are required and which are not fully defined, the remaining time estimate
  cannot be calculated.
  """
  timeEstimateRange: CategorizedTimeRange

  existence: Existence!

  system: Boolean!
}

scalar GroupId

"Groups contain observations and other groups. Exactly one will be defined."
type GroupElement {
  parentGroupId: GroupId
  parentIndex: NonNegShort!
  group: Group
  observation: Observation
  existence: Existence!
}

"A group element identifier. Exactly one of groupId and observationId must be provided."
input GroupElementInput {
  groupId: GroupId
  observationId: ObservationId
}

input GroupPropertiesInput {

  "Group name (optional)."
  name: NonEmptyString

  "Group description (optional)."
  description: NonEmptyString

  "Minimum number of elements to be observed. If unspecified then all elements will be observed."
  minimumRequired: NonNegShort

  "If true, elements will be observed in order. Defaults to false if left unspecified."
  ordered: Boolean

  "If specified, elements will be separated by at least `minimumInterval`."
  minimumInterval: TimeSpanInput

  "If specified, elements will be separated by at most `maximumInterval`."
  maximumInterval: TimeSpanInput

  "Parent group (optional). If specified then parent index must also be specified."
  parentGroup: GroupId

  "Parent index. If unspecified then the element will appear first in the program or parent group (if specified). Cannot be set to null."
  parentGroupIndex: NonNegShort

  "Existence. Defaults to 'present' on creation. Change this value to delete a group (must be empty)."
  existence: Existence

}

"""
Group creation parameters.  One of programId, programReference or
proposalReference is required. (If two or more are provided, they must refer to
the same program.)
"""
input CreateGroupInput {
  programId: ProgramId
  proposalReference: ProposalReferenceLabel
  programReference: ProgramReferenceLabel
  SET: GroupPropertiesInput

  "Group elements specified here, if any, will be moved into the created group in the specified order."
  initialContents: [GroupElementInput]
}

"The result of creating a new group."
type CreateGroupResult {
  "The newly created group."
  group: Group!
}

"""
A period of time showing which position angles have guide stars available during the period.
The position angles are tested every 10 degrees.
"""
type GuideAvailabilityPeriod {
  "The start time of the availability period."
  start: Timestamp!

  "Then end time of the availability period."
  end:   Timestamp!

  "The position angles available during this period."
  posAngles: [Angle!]!
}

"""
The guide star(s) and related information
"""
type GuideEnvironment {
  """
  The position angle
  """
  posAngle: Angle!

  """
  A list of GuideProbeTargets, which essentially provides a mapping from guide probes to targets.
  """
  guideTargets: [GuideTarget!]!
}

"""
Enumeration for Guide Probes
"""
enum GuideProbe {
  PWFS_1

  PWFS_2

  GMOS_OIWFS
}

"""
Type that contains a guide probe and guide target information for use in the GuideEnvironment
"""
type GuideTarget {
  """
  The guide probe
  """
  probe: GuideProbe!

  """
  Target name.
  """
  name: NonEmptyString!

  """
  source profile
  """
  sourceProfile: SourceProfile!

  """
  Sidereal tracking information, if this is a sidereal target
  """
  sidereal: Sidereal

  """
  Nonsidereal tracking information, if this is a nonsidereal target
  """
  nonsidereal: Nonsidereal
}

"""
HII Region spectrum
"""
enum HiiRegionSpectrum {
  """
  HiiRegionSpectrum OrionNebula
  """
  ORION_NEBULA
}

"""
Target right ascension coordinate in format 'HH:MM:SS.sss'
"""
scalar HmsString

type HourAngleRange {
  """
  Minimum Hour Angle (hours)
  """
  minHours: BigDecimal!

  """
  Maximum Hour Angle (hours)
  """
  maxHours: BigDecimal!
}

"""
Image quality
"""
enum ImageQuality {
  """
  ImageQuality PointOne
  """
  POINT_ONE

  """
  ImageQuality PointTwo
  """
  POINT_TWO

  """
  ImageQuality PointThree
  """
  POINT_THREE

  """
  ImageQuality PointFour
  """
  POINT_FOUR

  """
  ImageQuality PointSix
  """
  POINT_SIX

  """
  ImageQuality PointEight
  """
  POINT_EIGHT

  """
  ImageQuality OnePointZero
  """
  ONE_POINT_ZERO

  """
  ImageQuality OnePointFive
  """
  ONE_POINT_FIVE

  """
  ImageQuality TwoPointZero
  """
  TWO_POINT_ZERO
}

"""
Timestamp of time in ISO-8601 representation in format '2011-12-03T10:15:30Z'
"""
scalar Timestamp

"""
Instrument
"""
enum Instrument {
  """
  Instrument AcqCam
  """
  ACQ_CAM

  """
  Instrument Bhros
  """
  BHROS

  """
  Instrument Flamingos2
  """
  FLAMINGOS2

  """
  Instrument Ghost
  """
  GHOST

  """
  Instrument GmosNorth
  """
  GMOS_NORTH

  """
  Instrument GmosSouth
  """
  GMOS_SOUTH

  """
  Instrument Gnirs
  """
  GNIRS

  """
  Instrument Gpi
  """
  GPI

  """
  Instrument Gsaoi
  """
  GSAOI

  """
  Instrument Michelle
  """
  MICHELLE

  """
  Instrument Nici
  """
  NICI

  """
  Instrument Nifs
  """
  NIFS

  """
  Instrument Niri
  """
  NIRI

  """
  Instrument Phoenix
  """
  PHOENIX

  """
  Instrument Trecs
  """
  TRECS

  """
  Instrument Visitor
  """
  VISITOR

  """
  Instrument Scorpio
  """
  SCORPIO

  """
  Instrument Alopeke
  """
  ALOPEKE

  """
  Instrument Zorro
  """
  ZORRO
}

"""
Describes an instrument configuration option for spectroscopy.
"""
type SpectroscopyConfigOption {
  name:               NonEmptyString!
  instrument:         Instrument!

  focalPlane:         FocalPlane!

  fpuLabel:           NonEmptyString! # e.g., '0.25"'
  slitWidth:          Angle!
  slitLength:         Angle!

  disperserLabel:     NonEmptyString! # e.g., 'B1200'
  filterLabel:        NonEmptyString  # e.g., 'JH'

  wavelengthMin:      Wavelength!
  wavelengthMax:      Wavelength!
  wavelengthOptimal:  Wavelength!
  wavelengthCoverage: Wavelength!

  resolution:         PosInt!

  adaptiveOptics:     Boolean!

  "A special capability (if any) that the configuration may have."
  capability:         SpectroscopyCapabilities

  site:               Site!

  """
  For GMOS North options, the GMOS North configuration.  Null for other
  instruments.
  """
  gmosNorth: SpectroscopyConfigOptionGmosNorth

  """
  For GMOS South options, the GMOS South configuration.  Null for other
  instruments.
  """
  gmosSouth: SpectroscopyConfigOptionGmosSouth

}

type SpectroscopyConfigOptionGmosNorth {
  fpu:     GmosNorthBuiltinFpu!
  grating: GmosNorthGrating!
  filter:  GmosNorthFilter
}

type SpectroscopyConfigOptionGmosSouth {
  fpu:     GmosSouthBuiltinFpu!
  grating: GmosSouthGrating!
  filter:  GmosSouthFilter
}

"""
An 'Int` in the range 0 to 100
"""
scalar IntPercent

"""
Contains the result of calling the ITC for a particular observation.  Since
the observation may contain multiple targets, there may be multiple results.
The "result" field contains the selected, representative, result for all
targets.  If there are multiple successful results, this will be the one that
prescribes the longest observation. If there is a mix of failures and
successes, the overall "result" will be a failure. The "all" field contains
results for all targets regardless.
"""
type ItcResultSet {
  selected: ItcResult!
  all:      [ItcResult!]
  index:    NonNegInt!
}

"""
A single ITC call result.
"""
type ItcResult {
  targetId:      TargetId!
  exposureTime:  TimeSpan!
  exposureCount: NonNegInt!
  signalToNoise: SignalToNoise!
}

type LineFluxIntegrated {
  value: PosBigDecimal!
  units: LineFluxIntegratedUnits!
}

"""
Line flux integrated units
"""
enum LineFluxIntegratedUnits {
  """
  W/m²
  """
  W_PER_M_SQUARED

  """
  erg/s/cm²
  """
  ERG_PER_S_PER_CM_SQUARED
}

type LineFluxSurface {
  value: PosBigDecimal!
  units: LineFluxSurfaceUnits!
}

"""
Line flux surface units
"""
enum LineFluxSurfaceUnits {
  """
  W/m²/arcsec²
  """
  W_PER_M_SQUARED_PER_ARCSEC_SQUARED

  """
  erg/s/cm²/arcsec²
  """
  ERG_PER_S_PER_CM_SQUARED_PER_ARCSEC_SQUARED
}

"""
A String value that cannot be empty
"""
scalar NonEmptyString

"""
A `BigDecimal` greater than or equal to 0
"""
scalar NonNegBigDecimal

"""
A `Short` in the range from 0 to 32767
"""
scalar NonNegShort

"""
An `Int` in the range from 0 to 2147483647
"""
scalar NonNegInt

"""
An `Long` in the range from 0 to 9223372036854775807
"""
scalar NonNegLong

type Nonsidereal {
  """
  Human readable designation that discriminates among ephemeris keys of the same type.
  """
  des: String!

  """
  Nonsidereal target lookup type.
  """
  keyType: EphemerisKeyType!

  """
  Synthesis of `keyType` and `des`
  """
  key: String!
}

"""
Observation operational/active status options
"""
enum ObsActiveStatus {
  """
  ObsActiveStatus Active
  """
  ACTIVE

  """
  ObsActiveStatus Inactive
  """
  INACTIVE
}

"""
Observation status options
"""
enum ObsStatus {
  """
  ObsStatus New
  """
  NEW

  """
  ObsStatus Included
  """
  INCLUDED

  """
  ObsStatus Proposed
  """
  PROPOSED

  """
  ObsStatus Approved
  """
  APPROVED

  """
  ObsStatus ForReview
  """
  FOR_REVIEW

  """
  ObsStatus Ready
  """
  READY

  """
  ObsStatus Ongoing
  """
  ONGOING

  """
  ObsStatus Observed
  """
  OBSERVED
}

"""
Timing window inclusion options. Exclusions always take precedence over inclusions.
"""
enum TimingWindowInclusion {
  """
  Inclusion Timing Window
  """
  INCLUDE

  """
  Exclusion Timing Window
  """
  EXCLUDE
}

"""
Timing window repetition
"""
type TimingWindowRepeat {
  """
  Repeat period, counting from the start of the window.
  """
  period: TimeSpan!

  """
  Repetition times. If absent, will repeat forever.
  """
  times: PosInt
}

"""
Timing window end at a specified date and time.
"""
type TimingWindowEndAt {
  """
  Window end date and time, in UTC.
  """
  atUtc: Timestamp!
}

"""
Timing window end after a period of time.
"""
type TimingWindowEndAfter {
  """
  Window duration.
  """
  after: TimeSpan!

  """
  Window repetetion. If absent, will not repeat.
  """
  repeat: TimingWindowRepeat
}

"""
Timing window end.
"""
union TimingWindowEnd = TimingWindowEndAt | TimingWindowEndAfter

type TimingWindow {
  """
  Whether this is an INCLUDE or EXCLUDE window.
  """
  inclusion: TimingWindowInclusion!

  """
  Window start time, in UTC.
  """
  startUtc: Timestamp!

 """
 Window end. If absent, the window will never end.
 """
  end: TimingWindowEnd
}

type Observation {
  """
  Observation ID
  """
  id: ObservationId!

  """
  DELETED or PRESENT
  """
  existence: Existence!

  """
  Observation reference, if any (requires the existence of a reference for the
  program itself).
  """
  reference: ObservationReference

  """
  Observation index, relative to other observations in the same program.
  """
  index: PosInt!

  """
  Observation title generated from id and targets
  """
  title: NonEmptyString!

  """
  User-supplied observation-identifying detail information
  """
  subtitle: NonEmptyString

  """
  Observations are associated with a science band once time has been allocated
  to a program.
  """
  scienceBand: ScienceBand

  """
  Reference time used for execution and visualization and time-dependent calculations 
  (e.g., average parallactic angle and guide star selection)
  """
  observationTime: Timestamp

  """
  Used in conjunction with observationTime for time-dependentent calulations. If not
  set, the remaining observation execution time will be used.
  """
  observationDuration: TimeSpan

  """
  Position angle constraint, if any.
  """
  posAngleConstraint: PosAngleConstraint!

  """
  The program that contains this observation
  """
  program: Program!

  """
  The observation's target(s)
  """
  targetEnvironment: TargetEnvironment!

  """
  The constraint set for the observation
  """
  constraintSet: ConstraintSet!

  """
  Observation timing windows
  """
  timingWindows: [TimingWindow!]!

  """
  attachments
  """
  attachments: [Attachment!]!

  """
  The top level science requirements
  """
  scienceRequirements: ScienceRequirements!

  """
  The science configuration
  """
  observingMode: ObservingMode

  """
  The instrument in use for this observation, if the observing mode is set.
  """
  instrument: Instrument

  # Manual instrument configuration
  # manualConfig: ManualConfig

  """
  Execution sequence and runtime artifacts
  """
  execution: Execution!

  """
  The ITC result for this observation, assuming it has associated target(s)
  and a selected observing mode.
  """
  itc: Itc!

  """
  Enclosing group, if any.
  """
  groupId: GroupId

  """
  Index in enclosing group or at the top level if ungrouped. If left unspecified on creation, observation will be added last in its enclosing group or at the top level. Cannot be set to null.
  """
  groupIndex: NonNegShort!

  """
  The Calibration role of this observation
  """
  calibrationRole: CalibrationRole

  """
  Notes for the observer
  """
  observerNotes: NonEmptyString

  """
  Parameters relevant to approved configurations.
  """
  configuration: Configuration!

  """
  Program configuration requests applicable to this observation.
  """
  configurationRequests: [ConfigurationRequest!]!


  workflow: ObservationWorkflow!

}

enum ExecutionState {

  """
  The sequence or observation isn't sufficiently defined, or there is a problem
  that must first be resolved.
  """
  NOT_DEFINED

  "No execution visit has been recorded."
  NOT_STARTED

  """
  At least one visit was made, but the sequence or observation is not yet
  complete.
  """
  ONGOING

  "No more data is expected."
  COMPLETED

}


type Configuration {
  conditions: ConfigurationConditions!
  referenceCoordinates: Coordinates # may not be available
  observingMode: ConfigurationObservingMode
}

type ConfigurationConditions {
  imageQuality: ImageQuality!
  cloudExtinction: CloudExtinction!
  skyBackground: SkyBackground!
  waterVapor: WaterVapor!
}

type ConfigurationObservingMode {
  instrument: Instrument!
  mode: ObservingModeType!
  gmosNorthLongSlit: ConfigurationGmosNorthLongSlit
  gmosSouthLongSlit: ConfigurationGmosSouthLongSlit
}

type ConfigurationGmosNorthLongSlit {
  grating: GmosNorthGrating!
}

type ConfigurationGmosSouthLongSlit {
  grating: GmosSouthGrating!
}

scalar ConfigurationRequestId

enum ConfigurationRequestStatus {
  REQUESTED
  APPROVED
  DENIED
  WITHDRAWN
}

type ConfigurationRequest {
  id: ConfigurationRequestId!
  program: Program!
  status: ConfigurationRequestStatus!
  configuration: Configuration!
  applicableObservations: [ObservationId!]!
}

input CreateConfigurationRequestInput {
  observationId: ObservationId
}

type Itc {
  """
  The ITC result for the science part of the sequence
  """
  science: ItcResultSet!

  """
  The ITC result for the acquisition part of the sequence
  """
  acquisition: ItcResultSet!

}

"""
ObservationId id formatted as `o-[1-9a-f][0-9a-f]*`
"""
scalar ObservationId

"""
The matching observation results, limited to a maximum of 1000 entries.
"""
type ObservationSelectResult {
  """
  Matching observations up to the return size limit of 1000
  """
  matches: [Observation!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
The matching configuration requests, limited to a maximum of 1000 entries.
"""
type ConfigurationRequestSelectResult {
  """
  Matching configuration requests up to the return size limit of 1000
  """
  matches: [ConfigurationRequest!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
Observation reference type, broken into its constituient parts and including
a formatted label.
"""
type ObservationReference {

  "Formatted observation reference label."
  label:   ObservationReferenceLabel!

  "The program reference."
  program: ProgramReference!

  "The observation index relative to its program."
  index:   PosInt!
}

"""
Observation reference, formatted according to the program type, suffixed with
observation index. For example, G-2024B-1234-Q-0001 where G-2024B-1234-Q is
the program reference label and the observation index is 1.
"""
scalar ObservationReferenceLabel

"""
An observation validation problem
"""
type ObservationValidation {
  """
  The type of validation problem
  """
  code: ObservationValidationCode!

  """
  Particular errors for this validation type
  """
  messages: [String!]!
}

"""
Types of observation validations
"""
enum ObservationValidationCode {
  """
  The observation is not configured correctly and cannot be executed
  """
  CONFIGURATION_ERROR,

  """
  The observation does not meet the requirements of the Call for Proposals
  """
  CFP_ERROR,

  """
  The observation does not have valid ITC results.
  """
  ITC_ERROR

  CONFIG_REQUEST_UNAVAILABLE
  CONFIG_REQUEST_NOT_REQUESTED
  CONFIG_REQUEST_DENIED
  CONFIG_REQUEST_PENDING

}

"""
Each step in a sequence is tagged with an observe class which identifies its
purpose and who is ultimately charged for the time for that observe.
"""
enum ObserveClass {

  """
  Science dataset, charged to the program.
  """
  SCIENCE

  """
  Nighttime calibration, charged to the program.
  """
  PROGRAM_CAL

  """
  Nighttime calibration, charged to the partner.
  """
  PARTNER_CAL

  """
  Acquisition, charged to the program.
  """
  ACQUISITION

  """
  Acquisition calibration, charged to the program.
  """
  ACQUISITION_CAL

  """
  Daytime calibration, charged to the observatory.
  """
  DAY_CAL

}

type Parallax {
  """
  Parallax in microarcseconds
  """
  microarcseconds: Long!

  """
  Parallax in milliarcseconds
  """
  milliarcseconds: BigDecimal!
}

"""
Planet spectrum
"""
enum PlanetSpectrum {
  """
  PlanetSpectrum Mars
  """
  MARS

  """
  PlanetSpectrum Jupiter
  """
  JUPITER

  """
  PlanetSpectrum Saturn
  """
  SATURN

  """
  PlanetSpectrum Uranus
  """
  URANUS

  """
  PlanetSpectrum Neptune
  """
  NEPTUNE
}

"""
Planetary nebula spectrum
"""
enum PlanetaryNebulaSpectrum {
  """
  PlanetaryNebulaSpectrum NGC7009
  """
  NGC7009

  """
  PlanetaryNebulaSpectrum IC5117
  """
  IC5117
}

"""
Constraints (if any) on the observation's position angle.
"""
type PosAngleConstraint {

  """
  The position angle constraint mode in use.  The value will determine whether
  the angle is respected or ignored.
  """
  mode: PosAngleConstraintMode!

  """
  The fixed position angle.  This will be kept but ignored for UNBOUNDED and
  AVERAGE_PARALLACTIC modes.
  """
  angle: Angle!
}

"""
Position angle constraint type
"""
enum PosAngleConstraintMode {

  """
  PosAngleConstraintMode Unbounded
  """
  UNBOUNDED

  """
  PosAngleConstraintMode Fixed
  """
  FIXED

  """
  PosAngleConstraintMode AllowFlip
  """
  ALLOW_FLIP

  """
  PosAngleConstraintMode AverageParallactic
  """
  AVERAGE_PARALLACTIC

  """
  PosAngleConstraintMode ParallacticOverride
  """
  PARALLACTIC_OVERRIDE

}

"""
A `BigDecimal` greater than 0
"""
scalar PosBigDecimal

"""
An `Int` in the range from 1 to 2147483647
"""
scalar PosInt

"""
A `Short` in the range from 1 to 32767
"""
scalar PosShort

type Program {
  """
  Program ID
  """
  id: ProgramId!

  """
  DELETED or PRESENT
  """
  existence: Existence!

  """
  Program name
  """
  name: NonEmptyString

  "Program type"
  type: ProgramType!

  "Program reference, if any."
  reference: ProgramReference

  """
  Program proposal
  """
  proposal: Proposal

  """
  Proposal status of the program
  """
  proposalStatus: ProposalStatus!

  "Principal Investigator"
  pi: ProgramUser

  "Users assigned to this science program"
  users:   [ProgramUser!]!

  """
  All observations associated with the program.
  """
  observations(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ObservationSelectResult!

  """
  All configuration requests associated with the program.
  """
  configurationRequests(

    """
    Starts the result set at (or after if not existent) the given configuration request id.
    """
    OFFSET: ConfigurationRequestId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

  ): ConfigurationRequestSelectResult!

  """
  Attachments assocated with the program
  """
  attachments: [Attachment!]!

  "Top-level group elements (observations and sub-groups) in the program."
  groupElements(includeDeleted: Boolean! = false): [GroupElement!]!

  "All group elements (observations and sub-groups) in the program."
  allGroupElements(includeDeleted: Boolean! = false): [GroupElement!]!

  """
  Remaining execution time estimate range, assuming it can be calculated.  In
  order for an observation to have an estimate, it must be fully defined such
  that a sequence can be generated for it.  If a program has observations that
  are required and which are not fully defined, the remaining time estimate
  cannot be calculated.
  """
  timeEstimateRange: CategorizedTimeRange

  """
  Program-wide time charge, summing all corrected observation time charges.
  """
  timeCharge: [BandedTime!]!

  """
  All user invitations associated with this program.
  """
  userInvitations: [UserInvitation!]!

  """
  All partner time allocations.
  """
  allocations: [Allocation!]!

  """
  Calibration role of the program
  """
  calibrationRole: CalibrationRole

  """
  Observatory archive properties related to this program.
  """
  goa: GoaProperties!

}

"""
ProgramId id formatted as `p-[1-9a-f][0-9a-f]*`
"""
scalar ProgramId

"""
Defines the category of program references, where specific implementations exist
for calibration, engineering, etc.
"""
interface ProgramReference {
  label: ProgramReferenceLabel!
  type:  ProgramType!
}

type CalibrationProgramReference implements ProgramReference {
  label:         ProgramReferenceLabel!
  type:          ProgramType!
  instrument:    Instrument!
  semester:      Semester!
  semesterIndex: PosInt!
}

type CommissioningProgramReference implements ProgramReference {
  label:         ProgramReferenceLabel!
  type:          ProgramType!
  instrument:    Instrument!
  semester:      Semester!
  semesterIndex: PosInt!
}

type EngineeringProgramReference implements ProgramReference {
  label:         ProgramReferenceLabel!
  type:          ProgramType!
  instrument:    Instrument!
  semester:      Semester!
  semesterIndex: PosInt!
}

type ExampleProgramReference implements ProgramReference {
  label:         ProgramReferenceLabel!
  type:          ProgramType!
  instrument:    Instrument!
}

type LibraryProgramReference implements ProgramReference {
  label:         ProgramReferenceLabel!
  type:          ProgramType!
  description:   NonEmptyString!
  instrument:    Instrument!
}

type MonitoringProgramReference implements ProgramReference {
  label:         ProgramReferenceLabel!
  type:          ProgramType!
  instrument:    Instrument!
  semester:      Semester!
  semesterIndex: PosInt!
}

type ScienceProgramReference implements ProgramReference {
  label:          ProgramReferenceLabel!
  type:           ProgramType!
  scienceSubtype: ScienceSubtype!
  semester:       Semester!
  semesterIndex:  PosInt!
}

type SystemProgramReference implements ProgramReference {
  label:         ProgramReferenceLabel!
  type:          ProgramType!
}

"""
Program reference, formatted according to the type.  For example, a Science
Program has format G-YYYY[AB]-NNNN+-[CDLFSV]. For example, G-2024B-1234-Q
where 2024B refers to the associated semester.
"""
scalar ProgramReferenceLabel

"""
The matching program results, limited to a maximum of 1000 entries.
"""
type ProgramSelectResult {
  """
  Matching programs up to the return size limit of 1000
  """
  matches: [Program!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

enum ProgramType {
  CALIBRATION
  ENGINEERING
  EXAMPLE
  LIBRARY
  SCIENCE
  SYSTEM
}

"""
The matching program user results, limited to a maximum of 1000 entries.
"""
type ProgramUserSelectResult {
  """
  Matching program users up to the return size limit of 1000
  """
  matches: [ProgramUser!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

type ProperMotion {
  """
  Proper motion in RA
  """
  ra: ProperMotionRA!

  """
  Proper motion in declination
  """
  dec: ProperMotionDeclination!
}

type ProperMotionDeclination {
  """
  Proper motion in properMotion μas/year
  """
  microarcsecondsPerYear: Long!

  """
  Proper motion in properMotion mas/year
  """
  milliarcsecondsPerYear: BigDecimal!
}

type ProperMotionRA {
  """
  Proper motion in properMotion μas/year
  """
  microarcsecondsPerYear: Long!

  """
  Proper motion in properMotion mas/year
  """
  milliarcsecondsPerYear: BigDecimal!
}

type Proposal {

  """
  The proposal reference, assuming the proposal has been submitted and
  assigned a semester.
  """
  reference: ProposalReference

  """
  The corresponding CallForProposals definition itself, if the call id has been
  set.
  """
  call: CallForProposals

  """
  Proposal title
  """
  title: NonEmptyString

  """
  Proposal TAC category
  """
  category: TacCategory

  """
  Abstract
  """
  abstract: NonEmptyString

  """
  Properties of this proposal that are dependent upon the Call for Proposals
  type.
  """
  type: ProposalType!
}

type ProposalReference {
  label:         ProposalReferenceLabel!
  semester:      Semester!
  semesterIndex: PosInt!
}

"""
Proposal reference for science programs, formatted as G-YYYY[AB]-NNNN+. For
example, G-2024B-1234 where 2024B refers to the associated semester.
"""
scalar ProposalReferenceLabel

"""
Metadata for `enum ProposalStatus`
"""
type ProposalStatusMeta {
  tag:   ProposalStatus!
  name:  String!
}

"""
Quasar spectrum
"""
enum QuasarSpectrum {
  """
  QuasarSpectrum QS0
  """
  QS0

  """
  QuasarSpectrum QS02
  """
  QS02
}

type Query {
  # All science targets (if any) for the given observation (or environment). Set `includeDeleted` to true to include any deleted targets in the asterism.
  # asterism(
  #   # Observation ID
  #   observationId: ObservationId!

  #   # Set to true to include deleted values
  #   includeDeleted: Boolean! = false
  # ): [Target!]!

  """
  Observations grouped by commonly held science asterisms. Identify the program
  by specifying only one of programId, programReference, or proposalReference.
  If more than one is provided, all must match.  If none are set, nothing will
  match.
  """
  asterismGroup(

    "Program ID"
    programId: ProgramId

    "Proposal Reference"
    proposalReference: ProposalReferenceLabel

    "Program reference"
    programReference: ProgramReferenceLabel

    """
    Filters the selection of observations.
    """
    WHERE: WhereObservation

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): AsterismGroupSelectResult!

  """
  Select a single Call for Proposals by id.
  """
  callForProposals(
    callForProposalsId: CallForProposalsId!
  ): CallForProposals

  """
  Select all Calls for Proposals.
  """
  callsForProposals(

    "Filters the selection of calls for proposals."
    WHERE: WhereCallForProposals

    "Starts the result set at (or after if not existent) the given id."
    OFFSET: CallForProposalsId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt

    "Set to true to include deleted values"
    includeDeleted: Boolean! = false
  ): CallsForProposalsSelectResult!

  """
  Observations grouped by commonly held constraints. Identify the program by
  specifying only one of programId, programReference, or proposalReference.  If
  more than one is provided, all must match.  If none are set, nothing will
  match.
  """
  constraintSetGroup(

    "Program ID"
    programId: ProgramId

    "Proposal Reference"
    proposalReference: ProposalReferenceLabel

    "Program reference"
    programReference: ProgramReferenceLabel

    """
    Filters the selection of observations.
    """
    WHERE: WhereObservation

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): ConstraintSetGroupSelectResult!


  """
  Returns the dataset with the given id or reference, if any.  Identify the
  dataset by specifying only one of datasetId or datasetReference. If more than
  one is provided, all must match.  If neither are set, nothing will match.
  """
  dataset(

    "Specify to lookup the dataset by its ID."
    datasetId: DatasetId

    "Specify to lookup the dataset by its reference."
    datasetReference: DatasetReferenceLabel

  ): Dataset

  """
  Select all datasets associated with a step or observation
  """
  datasets(
    """
    Filters the selection of datasets.
    """
    WHERE: WhereDataset

    """
    Starts the result set at (or after if not existent) the given dataset id.
    """
    OFFSET: DatasetId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): DatasetSelectResult!

  """
  Selects the first `LIMIT` matching execution events based on the provided `WHERE` parameter, if any.
  """
  events(
    """
    Filters the selection of execution events
    """
    WHERE: WhereExecutionEvent

    """
    Starts the result set at (or after if not existent) the given execution event id.
    """
    OFFSET: ExecutionEventId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ExecutionEventSelectResult!

  """
  Metadata for `enum FilterType`
  """
  filterTypeMeta: [FilterTypeMeta!]!

  """
  Returns the group indicated by the given groupId, if found.
  """
  group(
    groupId: GroupId!
  ): Group

  """
  Returns the observation with the given id or reference, if any.  Identify the
  observation by specifying only one of observationId or observationReference.
  If more than one is provided, all must match.  If neither are set, nothing
  will match.
  """
  observation(

    "Specify to lookup the observation by its ID."
    observationId: ObservationId

    "Specify to lookup the observation by its reference."
    observationReference: ObservationReferenceLabel

  ): Observation

  """
  Selects the first `LIMIT` matching observations based on the provided `WHERE` parameter, if any.
  """
  observations(
    """
    Filters the selection of observations.
    """
    WHERE: WhereObservation

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): ObservationSelectResult!



  """
  Selects the first `LIMIT` matching configuration requests based on the provided `WHERE` parameter, if any.
  """
  configurationRequests(
    
    """
    Filters the selection of observations.
    """
    WHERE: WhereConfigurationRequest

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ConfigurationRequestId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

  ): ConfigurationRequestSelectResult!



  """
  Observations grouped by commonly held observing modes. Identify the program by
  specifying only one of programId, programReference, or proposalReference.  If
  more than one is provided, all must match.  If none are set, nothing will
  match.
  """
  observingModeGroup(

    "Program ID"
    programId: ProgramId

    "Proposal Reference"
    proposalReference: ProposalReferenceLabel

    "Program reference"
    programReference: ProgramReferenceLabel

    """
    Filters the selection of observations.
    """
    WHERE: WhereObservation

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): ObservingModeGroupSelectResult!

  """
  Returns the program with the given id or reference, if any. Identify the
  program by specifying only one of programId, programReference, or
  proposalReference. If more than one is provided, all must match.  If none are
  set, nothing will match.
  """
  program(
    "Program ID"
    programId: ProgramId

    "Proposal Reference"
    proposalReference: ProposalReferenceLabel

    "Program Reference"
    programReference: ProgramReferenceLabel

  ): Program

  """
  Selects the first `LIMIT` matching programs based on the provided `WHERE` parameter, if any.
  """
  programs(
    """
    Filters the selection of programs.
    """
    WHERE: WhereProgram

    """
    Starts the result set at (or after if not existent) the given program id.
    """
    OFFSET: ProgramId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): ProgramSelectResult!

  """
  Selects the first `LIMIT` matching program users based on the provided `WHERE`
  parameter, if any.
  """
  programUsers(

    "Filters the selection of program users."
    WHERE: WhereProgramUser

    "Starts the result set at (or after if not existent) the given user id."
    OFFSET: UserId

    """
    Limits the result to at most this number of matches (but never more than
    1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include program users linked to deleted programs.
    """
    includeDeleted: Boolean! = false

  ): ProgramUserSelectResult!

  """
  Metadata for `enum ProposalStatus
  """
  proposalStatusMeta: [ProposalStatusMeta!]!

  # Observations grouped by commonly held science requirements
  # scienceRequirementsGroup(
  #   # Program ID
  #   programId: ProgramId!

  #   # Filters the selection of observations.
  #   WHERE: WhereObservation

  #   # Limits the result to at most this number of matches (but never more than 1000).
  #   LIMIT: NonNegInt

  #   # Set to true to include deleted values
  #   includeDeleted: Boolean! = false
  # ): ScienceRequirementsGroupSelectResult!

  """
  Spectroscopy configuration options matching the WHERE parameter.
  """
  spectroscopyConfigOptions(
    WHERE: WhereSpectroscopyConfigOption
  ): [SpectroscopyConfigOption!]!

  """
  Retrieves the target with the given id, if it exists
  """
  target(
    """
    Target ID
    """
    targetId: TargetId!
  ): Target

  # Target environment for the given observation (or environment id)
  # targetEnvironment(
  #   # Observation ID
  #   observationId: ObservationId!
  # ): TargetEnvironment

  # Observations grouped by common target environment
  # targetEnvironmentGroup(
  #   # Program ID
  #   programId: ProgramId!

  #   # Filters the selection of observations.
  #   WHERE: WhereObservation

  #   # Limits the result to at most this number of matches (but never more than 1000).
  #   LIMIT: NonNegInt

  #   # Set to true to include deleted values
  #   includeDeleted: Boolean! = false
  # ): TargetEnvironmentGroupSelectResult!

  """
  Observations grouped by commonly held targets. Identify the program by
  specifying only one of programId, programReference, or proposalReference. If
  more than one is provided, all must match.  If none are set, nothing will
  match.
  """
  targetGroup(

    "Program ID"
    programId: ProgramId

    "Proposal Reference"
    proposalReference: ProposalReferenceLabel

    "Program Reference"
    programReference: ProgramReferenceLabel

    """
    Filters the selection of observations.
    """
    WHERE: WhereObservation

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): TargetGroupSelectResult!

  """
  Selects the first `LIMIT` matching targets based on the provided `WHERE` parameter, if any.
  """
  targets(
    """
    Filters the selection of targets.
    """
    WHERE: WhereTarget

    """
    Starts the result set at (or after if not existent) the given target id.
    """
    OFFSET: TargetId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt

    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): TargetSelectResult!

}

type RadialVelocity {
  """
  Radial velocity in cm/s
  """
  centimetersPerSecond: Long!

  """
  Radial velocity in m/s
  """
  metersPerSecond: BigDecimal!

  """
  Radial velocity in km/s
  """
  kilometersPerSecond: BigDecimal!
}

type RightAscension {
  """
  Right Ascension (RA) in HH:MM:SS.SSS format
  """
  hms: HmsString!

  """
  Right Ascension (RA) in hours
  """
  hours: BigDecimal!

  """
  Right Ascension (RA) in degrees
  """
  degrees: BigDecimal!

  """
  Right Ascension (RA) in µas
  """
  microarcseconds: Long! @deprecated

  """
  Right Ascension (RA) in µs
  """
  microseconds: Long!

}

"""
Base science mode
"""
type ObservingMode {
  """
  Instrument
  """
  instrument: Instrument!

  """
  Mode type
  """
  mode: ObservingModeType!

  """
  GMOS North Long Slit mode
  """
  gmosNorthLongSlit: GmosNorthLongSlit

  """
  GMOS South Long Slit mode
  """
  gmosSouthLongSlit: GmosSouthLongSlit
}

type ObservingModeGroup {
  """
  Observations associated with the common value
  """
  observations(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ObservationSelectResult!

  """
  Commonly held value across the observations
  """
  observingMode: ObservingMode!

  """
  Link back to program.
  """
  program: Program!
}

"""
The matching ObservingModeGroup results, limited to a maximum of 1000 entries.
"""
type ObservingModeGroupSelectResult {
  """
  Matching ObservingModeGroups up to the return size limit of 1000
  """
  matches: [ObservingModeGroup!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
Mode Spectroscopy/Imaging
"""
enum ScienceMode {
  """
  ScienceMode Imaging
  """
  IMAGING

  """
  ScienceMode Spectroscopy
  """
  SPECTROSCOPY
}

"""
Science observation priorities.
"""
enum ScienceBand {
  BAND1

  BAND2

  BAND3

  BAND4
}

"""
Science program types, for science programs only (i.e., not calibration,
engineering, library, etc.).
"""
enum ScienceSubtype {
  CLASSICAL

  DIRECTORS_TIME

  FAST_TURNAROUND

  LARGE_PROGRAM

  POOR_WEATHER

  QUEUE

  DEMO_SCIENCE

  SYSTEM_VERIFICATION
}


type ScienceRequirements {
  """
  Science mode
  """
  mode: ScienceMode!

  """
  Spectroscopy requirements
  """
  spectroscopy: SpectroscopyScienceRequirements!
}

type ScienceRequirementsGroup {
  """
  IDs of observations that use the same constraints
  """
  observationIds: [ObservationId!]!

  """
  Observations associated with the common value
  """
  observations(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ObservationSelectResult!

  """
  Commonly held value across the observations
  """
  scienceRequirements: ScienceRequirements!
}

"""
The matching scienceRequirementsGroup results, limited to a maximum of 1000 entries.
"""
type ScienceRequirementsGroupSelectResult {
  """
  Matching scienceRequirementsGroups up to the return size limit of 1000
  """
  matches: [ScienceRequirementsGroup!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
Semester string (from 2000A) in the format YYYY[AB].  An abbreviated format,
which assumes the millennium 2000, is also permitted.  For example, 24A is read
as 2024A.
"""
scalar Semester

"""
Sequence-level command
"""
enum SequenceCommand {

  """
  SequenceCommand ABORT
  """
  ABORT

  """
  SequenceCommand CONTINUE
  """
  CONTINUE

  """
  SequenceCommand PAUSE
  """
  PAUSE

  """
  SequenceCommand START
  """
  START

  """
  SequenceCommand STOP
  """
  STOP
}

type SequenceDigest {

  """ObserveClass of the whole sequence. """
  observeClass: ObserveClass!

  """Time estimate for the whole sequence."""
  timeEstimate: CategorizedTime!

  """Unique offsets that occur in the sequence."""
  offsets: [Offset!]!

  """
  Total count of anticipated atoms, including the 'nextAtom', 'possibleFuture'
  and any remaining atoms not included in 'possibleFuture'.
  """
  atomCount: NonNegInt!

  """
  Execution state for the sequence. Note, acquisition sequences are never
  'COMPLETED'.  The execution state for the observation as a whole is that of
  the science sequence.
  """
  executionState: ExecutionState!
}

"""
Sequence-level events.  As commands are issued to execute a sequence, corresponding events are generated.
"""
type SequenceEvent implements ExecutionEvent {

  "Event id."
  id: ExecutionEventId!

  "Visit associated with this event."
  visit: Visit!

  "Observation whose execution produced this event."
  observation: Observation!

  "Time at which this event was received."
  received: Timestamp!

  "Event type."
  eventType: ExecutionEventType!

  "Sequence event data."
  command: SequenceCommand!

}

"""
Type of sequence, acquisition or science
"""
enum SequenceType {
  """
  SequenceType ACQUISITION
  """
  ACQUISITION

  """
  SequenceType SCIENCE
  """
  SCIENCE
}

type Sidereal {
  """
  Right ascension at epoch
  """
  ra: RightAscension!

  """
  Declination at epoch
  """
  dec: Declination!

  """
  Epoch, time of base observation
  """
  epoch: EpochString!

  """
  Proper motion per year in right ascension and declination
  """
  properMotion: ProperMotion

  """
  Radial velocity
  """
  radialVelocity: RadialVelocity

  """
  Parallax
  """
  parallax: Parallax

  """
  Catalog info, if any, describing from where the information in this target was obtained
  """
  catalogInfo: CatalogInfo
}

scalar SignalToNoise

"""
Signal to noise exposure time mode
"""
type SignalToNoiseMode {
  """
  Signal/Noise value
  """
  value: SignalToNoise!
}

"""
Telescope Sites
"""
enum Site {

  "Gemini North"
  GN

  "Gemini South"
  GS

}

"""
Coordinate limits per site.
"""
type SiteCoordinateLimits {

  """
  Gemini North coordinate limits.
  """
  north: CoordinateLimits!

  """
  Gemini South coordinate limits.
  """
  south: CoordinateLimits!

}

"""
Sky background
"""
enum SkyBackground {
  """
  SkyBackground Darkest
  """
  DARKEST

  """
  SkyBackground Dark
  """
  DARK

  """
  SkyBackground Gray
  """
  GRAY

  """
  SkyBackground Bright
  """
  BRIGHT
}

"""
Slew events.
"""
type SlewEvent implements ExecutionEvent {

  "Event id."
  id: ExecutionEventId!

  "Visit associated with this event."
  visit: Visit!

  "Observation whose execution produced this event."
  observation: Observation!

  "Time at which this event was received."
  received: Timestamp!

  "Event type."
  eventType: ExecutionEventType!

  "Slew event data."
  slewStage: SlewStage!

}


"Slew stage"
enum SlewStage {

  START_SLEW

  END_SLEW

}


"""
Source profile, exactly one of the fields will be defined
"""
type SourceProfile {
  """
  point source, integrated units
  """
  point: SpectralDefinitionIntegrated

  """
  uniform source, surface units
  """
  uniform: SpectralDefinitionSurface

  """
  gaussian source, integrated units
  """
  gaussian: GaussianSource
}

"""
Spectral definition integrated.  Exactly one of the fields will be defined.
"""
type SpectralDefinitionIntegrated {
  """
  Band normalized spectral definition
  """
  bandNormalized: BandNormalizedIntegrated

  """
  Emission lines spectral definition
  """
  emissionLines: EmissionLinesIntegrated
}

"""
Spectral definition surface.  Exactly one of the fields will be defined.
"""
type SpectralDefinitionSurface {
  """
  Band normalized spectral definition
  """
  bandNormalized: BandNormalizedSurface

  """
  Emission lines spectral definition
  """
  emissionLines: EmissionLinesSurface
}

"""
Spectroscopy capabilities Nod&Shuffle/Polarimetry/Corongraphy
"""
enum SpectroscopyCapabilities {
  """
  SpectroscopyCapabilities NodAndShuffle
  """
  NOD_AND_SHUFFLE

  """
  SpectroscopyCapabilities Polarimetry
  """
  POLARIMETRY

  """
  SpectroscopyCapabilities Coronagraphy
  """
  CORONAGRAPHY
}

type SpectroscopyScienceRequirements {
  """
  Requested central wavelength
  """
  wavelength: Wavelength

  """
  Requested resolution
  """
  resolution: PosInt

  """
  Requested signal to noise ratio
  """
  signalToNoise: SignalToNoise

  """
  Requested wavelength for the requested signal to noise
  """
  signalToNoiseAt: Wavelength

  """
  Wavelength range
  """
  wavelengthCoverage: Wavelength

  """
  Focal plane choice
  """
  focalPlane: FocalPlane

  """
  Focal plane angle
  """
  focalPlaneAngle: Angle

  """
  Spectroscopy Capabilities
  """
  capability: SpectroscopyCapabilities
}

"""
Stellar library spectrum
"""
enum StellarLibrarySpectrum {
  """
  StellarLibrarySpectrum O5V
  """
  O5_V

  """
  StellarLibrarySpectrum O8III
  """
  O8_III

  """
  StellarLibrarySpectrum B0V
  """
  B0_V

  """
  StellarLibrarySpectrum B5_7V
  """
  B5_7_V

  """
  StellarLibrarySpectrum B5III
  """
  B5_III

  """
  StellarLibrarySpectrum B5I
  """
  B5_I

  """
  StellarLibrarySpectrum A0V
  """
  A0_V

  """
  StellarLibrarySpectrum A0III
  """
  A0_III

  """
  StellarLibrarySpectrum A0I
  """
  A0_I

  """
  StellarLibrarySpectrum A5V
  """
  A5_V

  """
  StellarLibrarySpectrum A5III
  """
  A5_III

  """
  StellarLibrarySpectrum F0V
  """
  F0_V

  """
  StellarLibrarySpectrum F0III
  """
  F0_III

  """
  StellarLibrarySpectrum F0I
  """
  F0_I

  """
  StellarLibrarySpectrum F5V
  """
  F5_V

  """
  StellarLibrarySpectrum F5V_w
  """
  F5_V_W

  """
  StellarLibrarySpectrum F6V_r
  """
  F6_V_R

  """
  StellarLibrarySpectrum F5III
  """
  F5_III

  """
  StellarLibrarySpectrum F5I
  """
  F5_I

  """
  StellarLibrarySpectrum G0V
  """
  G0_V

  """
  StellarLibrarySpectrum G0V_w
  """
  G0_V_W

  """
  StellarLibrarySpectrum G0V_r
  """
  G0_V_R

  """
  StellarLibrarySpectrum G0III
  """
  G0_III

  """
  StellarLibrarySpectrum G0I
  """
  G0_I

  """
  StellarLibrarySpectrum G2V
  """
  G2_V

  """
  StellarLibrarySpectrum G5V
  """
  G5_V

  """
  StellarLibrarySpectrum G5V_w
  """
  G5_V_W

  """
  StellarLibrarySpectrum G5V_r
  """
  G5_V_R

  """
  StellarLibrarySpectrum G5III
  """
  G5_III

  """
  StellarLibrarySpectrum G5III_w
  """
  G5_III_W

  """
  StellarLibrarySpectrum G5III_r
  """
  G5_III_R

  """
  StellarLibrarySpectrum G5I
  """
  G5_I

  """
  StellarLibrarySpectrum K0V
  """
  K0_V

  """
  StellarLibrarySpectrum K0V_r
  """
  K0_V_R

  """
  StellarLibrarySpectrum K0III
  """
  K0_III

  """
  StellarLibrarySpectrum K0III_w
  """
  K0_III_W

  """
  StellarLibrarySpectrum K0III_r
  """
  K0_III_R

  """
  StellarLibrarySpectrum K0_1II
  """
  K0_1_II

  """
  StellarLibrarySpectrum K4V
  """
  K4_V

  """
  StellarLibrarySpectrum K4III
  """
  K4_III

  """
  StellarLibrarySpectrum K4III_w
  """
  K4_III_W

  """
  StellarLibrarySpectrum K4III_r
  """
  K4_III_R

  """
  StellarLibrarySpectrum K4I
  """
  K4_I

  """
  StellarLibrarySpectrum M0V
  """
  M0_V

  """
  StellarLibrarySpectrum M0III
  """
  M0_III

  """
  StellarLibrarySpectrum M3V
  """
  M3_V

  """
  StellarLibrarySpectrum M3III
  """
  M3_III

  """
  StellarLibrarySpectrum M6V
  """
  M6_V

  """
  StellarLibrarySpectrum M6III
  """
  M6_III

  """
  StellarLibrarySpectrum M9III
  """
  M9_III
}

"""
Step-level events.  The execution of a single step will generate multiple events.
"""
type StepEvent implements ExecutionEvent {

  "Event id"
  id: ExecutionEventId!

  "Visit associated with this event."
  visit: Visit!

  "Observation whose execution produced this event."
  observation: Observation!

  "Time at which this event was received"
  received: Timestamp!

  "Event type."
  eventType: ExecutionEventType!

  "Atom associated with this event."
  atom: AtomRecord!

  "Step associated with this event."
  step: StepRecord!

  "Step execution stage."
  stepStage: StepStage!

}

"StepId id formatted as `s-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}`"
scalar StepId

"Execution stage or phase of an individual step"
enum StepStage {

  ABORT

  CONTINUE

  END_CONFIGURE

  END_OBSERVE

  END_STEP

  PAUSE

  START_CONFIGURE

  START_OBSERVE

  START_STEP

  STOP

}

"""
An individual configuration change before a step is executed.  Multiple
items may change simultaneously (e.g., the science fold may move while the
Gcal filter is updated).  ConfigChangeEstimate identifies a single item that will
be updated.
"""
type ConfigChangeEstimate {

  """
  Name of the item that changed.
  """
  name: String!

  """
  A possibly longer description of what was updated.
  """
  description: String!

  """
  Estimated time required to effectuate the change.
  """
  estimate: TimeSpan!

}

"""
Time taken to update the configuration before a step is executed.
"""
type AllConfigChangeEstimates {

  """
  The selected ConfigChangeEstimate is a maximum of all the config change
  estimates.  In other words, one that takes the longest.
  """
  selected: ConfigChangeEstimate!

  """
  Index of the selected config change estimate amongst all the estimates in
  `all`.
  """
  index: NonNegInt!

  """
  Complete collection of items that changed.  The selected estimate will be
  one of the longest (there may be multiple estimates tied for the longest).
  """
  all: [ConfigChangeEstimate!]!

  """
  Time required for the collection of estimates in `all`.  This should
  be the max of the individual entries because the execution happens in
  parallel.
  """
  estimate: TimeSpan!

}

"""
Time estimate for taking an individual dataset.
"""
type DatasetEstimate {

  """
  The exposure time itself
  """
  exposure: TimeSpan!

  """
  Time required to readout the detector
  """
  readout: TimeSpan!

  """
  Time required to write the data to the storage system
  """
  write: TimeSpan!

  """
  Total estimate for the dataset, summing exposure, readout and write
  """
  estimate: TimeSpan!

}

"""
Time estimate for a single detector.  Some instruments will employ multiple
detectors per step.
"""
type DetectorEstimate {

  """
  Indicates which detector is estimated here
  """
  name: String!

  """
  Detector description
  """
  description: String!

  """
  Time estimate for a single dataset produced by this detector
  """
  dataset: DatasetEstimate!

  """
  Count of datasets to be produced by the detector
  """
  count: NonNegInt!

  """
  Total time estimate for the detector, which is the sum of the individual
  dataset estimate multiplied by the count.
  """
  estimate: TimeSpan!

}

"""
The collection of detector estimates involved in an individual step.
"""
type AllDetectorEstimates {

  """
  The selected DetectorEstimate is a maximum of all the detector estimates.
  In other words, one that takes the longest.
  """
  selected: DetectorEstimate!

  """
  Index of the selected detector estimate amongst all the estimates in
  `all`.
  """
  index: NonNegInt!

  """
  Complete collection of detectors involved in a step.  The selected estimate
  will be one of the longest (there may be multiple estimates tied for the
  longest).
  """
  all: [DetectorEstimate!]!

  """
  Time required for the collection of estimates in `all`.  This should
  be the max of the individual entries because the execution happens in
  parallel.
  """
  estimate: TimeSpan!

}

"""
Time estimate for an individual step, including configuration changes and
dataset production.
"""
type StepEstimate {

  """
  Configuration changes required before the step is executed.  This will
  obviously depend not only on the step configuration but also the previous
  step configuration.
  """
  configChange: AllConfigChangeEstimates

  """
  Time for producing the datasets for this step.
  """
  detector:     AllDetectorEstimates

  """
  Total time estimate for the step.
  """
  total:        TimeSpan!
}

"""
A step as recorded by Observe.  There will be one instrument configuration per
instrument, all but one of which will be null.
"""
type StepRecord {

  "Step ID."
  id: StepId!

  "Step Index, relative to other step records in the observation."
  index: PosInt!

  """
  Instrument associated with the step. This will indicate which of the
  instrument-specific dynamic fields (e.g., `gmosNorth: GmosNorthDynamic`) is
  defined.
  """
  instrument: Instrument!

  "The atom in which the step was executed."
  atom: AtomRecord!

  "The step was created by Observe at this time."
  created: Timestamp!

  """
  The execution state of this step, according to events received (if any) from
  Observe.
  """
  executionState: StepExecutionState!

  """
  Time interval during which this step executed.  This measures the range of
  time from the first event to the last, whether or not the step ever
  actually completed.  A 'null' result means there are no events associated
  with this step.
  """
  interval: TimestampInterval

  """
  The step configuration, apart from instrument details found in the
  instrument-specific 'StepRecord' implementation.
  """
  stepConfig: StepConfig!

  "The telescope configuration for this step."
  telescopeConfig: TelescopeConfig!

  "The observe class of this step."
  observeClass: ObserveClass!

  "Original time estimate for executing this step."
  estimate: TimeSpan!

  """
  QA state based on a combination of dataset QA states.  The worst QA state is
  taken as the overall step QA state.  For example, one FAIL dataset will
  result in the step having a FAIL QA state.  Unset QA states are ignored, but
  if none are set the result will be null.
  """
  qaState: DatasetQaState

  "Datasets associated with this step."
  datasets(
    "Starts the result set at (or after if not existent) the given dataset id."
    OFFSET: DatasetId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): DatasetSelectResult!

  "Execution events associated with this step."
  events(
    "Starts the result set at (or after if not existent) the given execution event id."
    OFFSET: ExecutionEventId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): ExecutionEventSelectResult!

  "Step ID of the generated step, if any, that produced this step record."
  generatedId: StepId

  """
  GMOS North instrument configuration for this step, if any.  This will be null
  unless the `instrument` discriminator is "GMOS_NORTH".
  """
  gmosNorth: GmosNorthDynamic

  """
  GMOS South instrument configuration for this step, if any.  This will be null
  unless the `instrument` discriminator is "GMOS_SOUTH".
  """
  gmosSouth: GmosSouthDynamic
}

"StepRecord query results, limited to a maximum of 1000 entries."
type StepRecordSelectResult {

  "Matching step records up to the return size limit of 1000."
  matches: [StepRecord!]!

  "`true` when there were additional matches that were not returned."
  hasMore: Boolean!

}

"""
TAC Category
"""
enum TacCategory {
  """
  TacCategory SmallBodies
  """
  SMALL_BODIES

  """
  TacCategory PlanetaryAtmospheres
  """
  PLANETARY_ATMOSPHERES

  """
  TacCategory PlanetarySurfaces
  """
  PLANETARY_SURFACES

  """
  TacCategory SolarSystemOther
  """
  SOLAR_SYSTEM_OTHER

  """
  TacCategory ExoplanetRadialVelocities
  """
  EXOPLANET_RADIAL_VELOCITIES

  """
  TacCategory ExoplanetAtmospheresActivity
  """
  EXOPLANET_ATMOSPHERES_ACTIVITY

  """
  TacCategory ExoplanetTransits
  """
  EXOPLANET_TRANSITS

  """
  TacCategory ExoplanetHostStar
  """
  EXOPLANET_HOST_STAR

  """
  TacCategory ExoplanetOther
  """
  EXOPLANET_OTHER

  """
  TacCategory StellarAstrophysics
  """
  STELLAR_ASTROPHYSICS

  """
  TacCategory StellarPopulations
  """
  STELLAR_POPULATIONS

  """
  TacCategory StarFormation
  """
  STAR_FORMATION

  """
  TacCategory GaseousAstrophysics
  """
  GASEOUS_ASTROPHYSICS

  """
  TacCategory StellarRemnants
  """
  STELLAR_REMNANTS

  """
  TacCategory GalacticOther
  """
  GALACTIC_OTHER

  """
  TacCategory Cosmology
  """
  COSMOLOGY

  """
  TacCategory ClustersOfGalaxies
  """
  CLUSTERS_OF_GALAXIES

  """
  TacCategory HighZUniverse
  """
  HIGH_Z_UNIVERSE

  """
  TacCategory LowZUniverse
  """
  LOW_Z_UNIVERSE

  """
  TacCategory ActiveGalaxies
  """
  ACTIVE_GALAXIES

  """
  TacCategory ExtragalacticOther
  """
  EXTRAGALACTIC_OTHER
}

"""
Calibration role
Observations/Programs/Targets can have a calibration role
"""
enum CalibrationRole {

  """
  CalibrationRole Twilight
  """
  TWILIGHT

  """
  CalibrationRole Photometric
  """
  PHOTOMETRIC

  """
  CalibrationRole SpectroPhotometric
  """
  SPECTROPHOTOMETRIC

  """
  CalibrationRole Telluric
  """
  TELLURIC
}

"""
Target description
"""
type Target {
  """
  Target ID
  """
  id: TargetId!

  """
  DELETED or PRESENT
  """
  existence: Existence!

  """
  Program that contains this target
  """
  program(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): Program!

  """
  Target name.
  """
  name: NonEmptyString!

  """
  calibration role
  """
  calibrationRole: CalibrationRole

  """
  source profile
  """
  sourceProfile: SourceProfile!

  """
  Sidereal tracking information, if this is a sidereal target
  """
  sidereal: Sidereal

  """
  Nonsidereal tracking information, if this is a nonsidereal target
  """
  nonsidereal: Nonsidereal
}

type TargetEnvironment {
  """
  All the observation's science targets, if any
  """
  asterism(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): [Target!]!

  """
  First, perhaps only, science target in the asterism
  """
  firstScienceTarget(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false
  ): Target

  """
  Explicit (if defined) or computed base position at the specified time, if known.
  """
  basePosition(
    """
    The time used for the base position calculations.
    """
    observationTime: Timestamp!
  ): Coordinates

  """
  The guide star(s) and related information
  """
  guideEnvironments(
    """
    The time used for the guide star calculations.
    """
    observationTime: Timestamp!
  ): [GuideEnvironment!]!

  """
  The guide target(s) and related information.
  If a guide target has been set via `guideTargetName`, that target will be
  returned. If it not found or not usable, an error will be returned.
  If no guide target has been set, or it has been invalidated by observation/target
  changes, Gaia will be searched for the best guide target available.
  """
  guideEnvironment: GuideEnvironment!

  """
  Availability of guide stars during a specified time range.
  There can be multiple `GuideAvailabilityPeriod`s returned if availability changes over the time
  range. In this case, the `end` of one period will be the same as the `start` of the next period.
  """
  guideAvailability(
    "The starting time of the time range of interest."
    start: Timestamp!

    "The ending time of the time range of interest."
    end:   Timestamp!
  ): [GuideAvailabilityPeriod!]!

  """
  When set, overrides the default base position of the target group
  """
  explicitBase: Coordinates

  """
  The name of the guide target, if any, set by `setGuideTargetName`.
  If the name is no longer valid or a sequence cannot be generated, null will
  be returned.
  """
  guideTargetName: NonEmptyString
}

type TargetEnvironmentGroup {
  """
  IDs of observations that use the same constraints
  """
  observationIds: [ObservationId!]!

  """
  Observations associated with the common value
  """
  observations(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ObservationSelectResult!

  """
  Commonly held value across the observations
  """
  targetEnvironment: TargetEnvironment!
}

"""
The matching targetEnvironmentGroup results, limited to a maximum of 1000 entries.
"""
type TargetEnvironmentGroupSelectResult {
  """
  Matching targetEnvironmentGroups up to the return size limit of 1000
  """
  matches: [TargetEnvironmentGroup!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

type TargetGroup {

  """
  Observations associated with the common value
  """
  observations(
    """
    Set to true to include deleted values
    """
    includeDeleted: Boolean! = false

    """
    Starts the result set at (or after if not existent) the given observation id.
    """
    OFFSET: ObservationId

    """
    Limits the result to at most this number of matches (but never more than 1000).
    """
    LIMIT: NonNegInt
  ): ObservationSelectResult!

  """
  Commonly held value across the observations
  """
  target: Target!

  """
  Link back to program.
  """
  program: Program!

}

"""
The matching targetGroup results, limited to a maximum of 1000 entries.
"""
type TargetGroupSelectResult {
  """
  Matching targetGroups up to the return size limit of 1000
  """
  matches: [TargetGroup!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
TargetId id formatted as `t-[1-9a-f][0-9a-f]*`
"""
scalar TargetId

"""
The matching target results, limited to a maximum of 1000 entries.
"""
type TargetSelectResult {
  """
  Matching targets up to the return size limit of 1000
  """
  matches: [Target!]!

  """
  `true` when there were additional matches that were not returned.
  """
  hasMore: Boolean!
}

"""
A manual correction to time accounting calculations.  Note that the
application of a correction is bounded by a zero time span and the
maximum time span.
"""
type TimeChargeCorrection {

  "When the correction was made."
  created:     Timestamp!

  "The charge class to be corrected."
  chargeClass: ChargeClass!

  "The operation (add or subtract) to perform."
  op:          TimeChargeCorrectionOp!

  "The amount of time to add or subtract (respecting the min and max time span)."
  amount:      TimeSpan!

  "The user responsible for the change."
  user:        User

  "Optional justification for the correction."
  comment:     NonEmptyString
}

"""
Describes a manual correction to time accounting calculations.
"""
input TimeChargeCorrectionInput {

  "The charge class to be corrected."
  chargeClass: ChargeClass!

  "The operation (add or subtract) to perform."
  op:          TimeChargeCorrectionOp!

  "The amount of time to add or subtract (respecting the min and max time span)."
  amount:      TimeSpanInput!

  "Optional justification for the correction."
  comment:     String
}

"Time accounting correction operations."
enum TimeChargeCorrectionOp {
  ADD,
  SUBTRACT
}

"""
Describes a time charge discount, broken out by charge class (program vs.
partner).  For each class, the associated time is subtracted and then added to
uncharged.
"""
interface TimeChargeDiscount {

  "The interval during which this discount applies."
  interval: TimestampInterval!

  "Time amount to discount from the partner."
  partner: TimeSpan!

  "Time amount to discount from the program."
  program: TimeSpan!

  "Additional detail."
  comment: String!

}

"""
A time charge discount that is applied when part of the observation is executed
outside of nautical twilight boundaries.  The portion that occurs during day
time is not charged.
"""
type TimeChargeDaylightDiscount implements TimeChargeDiscount {

  "The interval during which this discount applies."
  interval: TimestampInterval!

  "Time amount to discount from the partner."
  partner: TimeSpan!

  "Time amount to discount from the program."
  program: TimeSpan!

  "Additional detail."
  comment: String!

  "The site where the observation was executed."
  site: Site!

}

"""
A time charge discount that is applied when no data is collected during the
entirety of the visit.
"""
type TimeChargeNoDataDiscount implements TimeChargeDiscount {
  "The interval during which this discount applies."
  interval: TimestampInterval!

  "Time amount to discount from the partner."
  partner: TimeSpan!

  "Time amount to discount from the program."
  program: TimeSpan!

  "Additional detail."
  comment: String!
}

type TimeChargeQaDiscount implements TimeChargeDiscount {

  "The interval during which this discount applies."
  interval: TimestampInterval!

  "Time amount to discount from the partner."
  partner: TimeSpan!

  "Time amount to discount from the program."
  program: TimeSpan!

  "Additional detail."
  comment: String!

  "Datasets associated with the discount."
  datasets: [Dataset!]!

}

# TBD
#type TimeChargeFaultDiscount implements TimeChargeDiscount
#type TimeChargeWeatherDiscount implements TimeChargeDiscount

"""
Detailed time accounting information for a visit, showing the raw execution
time along with any automatically applied discounts (e.g., for bad weather)
and manual adjustments made by staff.
"""
type TimeChargeInvoice {

  "Raw execution time."
  executionTime: CategorizedTime!

  "Automatic discounts for weather loss, fault reports, and non-passing datasets."
  discounts: [TimeChargeDiscount!]!

  "Any manual corrections to the execution time."
  corrections: [TimeChargeCorrection!]!

  """
  Final time charge once discounts and corrections have been applied to the
  initial 'executionTime'.
  """
  finalCharge: CategorizedTime!

}

"""
Equivalent time amount in several unit options (e.g., 120 seconds or 2 minutes)
"""
type TimeSpan {
  """
  TimeSpan in µs
  """
  microseconds: Long!

  """
  TimeSpan in ms
  """
  milliseconds: BigDecimal!

  """
  TimeSpan in seconds
  """
  seconds: BigDecimal!

  """
  TimeSpan in minutes
  """
  minutes: BigDecimal!

  """
  TimeSpan in hours
  """
  hours: BigDecimal!

  """
  TimeSpan as an ISO-8601 string
  """
  iso: String!
}

"""
Equivalent time amount in several unit options (exactly one must be specified)
"""
input TimeSpanInput {
  """
  TimeSpan in µs
  """
  microseconds: Long

  """
  TimeSpan in ms
  """
  milliseconds: BigDecimal

  """
  TimeSpan in seconds
  """
  seconds: BigDecimal

  """
  TimeSpan in minutes
  """
  minutes: BigDecimal

  """
  TimeSpan in hours
  """
  hours: BigDecimal

  """
  TimeSpan as an ISO-8601 string
  """
  iso: String
}

"""
Time interval marked by a start 'Timestamp' (inclusive) and an end 'Timestamp'
(exclusive).
"""
type TimestampInterval {

  "Start time of the interval (inclusive)."
  start: Timestamp!

  "End time of the interval (exclusive)."
  end: Timestamp!

  "Duration of the interval."
  duration: TimeSpan!

}

"""
ToO Activation
"""
enum ToOActivation {
  """
  ToOActivation None
  """
  NONE

  """
  ToOActivation Standard
  """
  STANDARD

  """
  ToOActivation Rapid
  """
  RAPID
}

input UnlinkUserInput {

  "The program to unlink the user from."
  programId: ProgramId!

  "The user to unlink."
  userId: UserId!

}

type UnlinkUserResult {
  "Returns true if the user was unlinked, false if no such link existed."
  result: Boolean!
}

"""
Un-normalized spectral energy distribution.  Exactly one of the definitions will be non-null.
"""
type UnnormalizedSed {
  stellarLibrary: StellarLibrarySpectrum
  coolStar: CoolStarTemperature
  galaxy: GalaxySpectrum
  planet: PlanetSpectrum
  quasar: QuasarSpectrum
  hiiRegion: HiiRegionSpectrum
  planetaryNebula: PlanetaryNebulaSpectrum
  powerLaw: BigDecimal
  blackBodyTempK: PosInt
  fluxDensities: [FluxDensityEntry!]
}

scalar UserId

enum UserType {
  GUEST
  STANDARD
  SERVICE
}

type User {
  id:          UserId!
  type:        UserType!
  serviceName: String,
  orcidId:     String,
  profile:     UserProfile!
}

type UserProfile {
  givenName:  String
  familyName: String
  creditName: String
  email:      String
}

input UserProfileInput {
  givenName:  String
  familyName: String
  creditName: String
  email:      String
}

"""
A visit is recorded whenever any part of an observation is attempted.  There
is a specific static configuration for each instrument, only one of which is
defined.  The same static configuration holds for the entire visit.
"""
type Visit {

  "Visit id."
  id: VisitId!

  """
  Instrument in use for this visit.  This serves as a discriminator between the
  various specific static instrument configuration types (e.g.,
  `gmosNorth: GmosNorthStatic`.)
  """
  instrument: Instrument!

  "Observation associated with this visit."
  observation: Observation!

  "Created by Observe at time."
  created: Timestamp!

  "Time interval during which this visit executed."
  interval: TimestampInterval

  "Executed (or at least partially executed) atom records for this visit."
  atomRecords(
    "Starts the result set at the given atom creation time."
    OFFSET: Timestamp

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): AtomRecordSelectResult!

  "Datasets associated with this visit."
  datasets(
    "Starts the result set at (or after if not existent) the given dataset id."
    OFFSET: DatasetId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): DatasetSelectResult!

  "Execution events associated with this visit."
  events(
    "Starts the result set at (or after if not existent) the given execution event id."
    OFFSET: ExecutionEventId

    "Limits the result to at most this number of matches (but never more than 1000)."
    LIMIT: NonNegInt
  ): ExecutionEventSelectResult!

  "Time accounting details for this visit."
  timeChargeInvoice: TimeChargeInvoice!

  """
  GmosNorth static instrument configuration, for GMOS North visits.  See the
  `instrument` discriminator.  This will be null unless the instrument is
  `GMOS_NORTH`.
  """
  gmosNorth: GmosNorthStatic

  """
  GmosSouth static instrument configuration, for GMOS South visits.  See the
  `instrument` discriminator.  This will be null unless the instrument is
  `GMOS_SOUTH`.
  """
  gmosSouth: GmosSouthStatic

}

"""
Matching visit results, limited to a maximum of 1000 entries.
"""
type VisitSelectResult {

  "Matching visits up to the return size limit of 1000."
  matches: [Visit!]!

  "`true` when there were additional matches that were not returned."
  hasMore: Boolean!
}

"""
VisitId id formatted as `v-[1-9a-f][0-9a-f]*`
"""
scalar VisitId

"""
Water vapor
"""
enum WaterVapor {
  """
  WaterVapor VeryDry
  """
  VERY_DRY

  """
  WaterVapor Dry
  """
  DRY

  """
  WaterVapor Median
  """
  MEDIAN

  """
  WaterVapor Wet
  """
  WET
}

type Wavelength {
  """
  Wavelength in pm
  """
  picometers: PosInt!

  """
  Wavelength in Å
  """
  angstroms: PosBigDecimal!

  """
  Wavelength in nm
  """
  nanometers: PosBigDecimal!

  """
  Wavelength in µm
  """
  micrometers: PosBigDecimal!
}

"""
A WavelengthDither is expressed in the same units as Wavelength but
constrained to positive values.  It expresses an "offset" to a given
Wavelength.
"""
type WavelengthDither {
  """
  Wavelength dither in pm
  """
  picometers: Int!

  """
  Wavelength dither in Å
  """
  angstroms: BigDecimal!

  """
  Wavelength dither in nm
  """
  nanometers: BigDecimal!

  """
  Wavelength dither in µm
  """
  micrometers: BigDecimal!
}

input WhereAngle {

  AND: [WhereAngle!]

  OR: [WhereAngle!]

  NOT: WhereAngle

  microarcseconds: WhereOrderLong

  microseconds: WhereOrderBigDecimal

  milliarcseconds: WhereOrderBigDecimal

  milliseconds: WhereOrderBigDecimal

  arcseconds: WhereOrderBigDecimal

  seconds: WhereOrderBigDecimal

  arcminutes: WhereOrderBigDecimal

  minutes: WhereOrderBigDecimal

  degrees: WhereOrderBigDecimal

  hours: WhereOrderBigDecimal

}

input WhereBoolean {

  """
  Matches if the boolean is the provided value.
  """
  EQ: Boolean

}

input WhereOptionBoolean {
  """
  Matches if the value is not defined.
  """
  IS_NULL: Boolean


  """
  Matches if the boolean is the provided value.
  """
  EQ: Boolean

}


input WhereCallForProposals {

  """
  A list of nested call for proposals filters that all must match in order for
  the AND group as a whole to match.
  """
  AND: [WhereCallForProposals!]

  """
  A list of nested call for proposals filters where any one match causes the
  entire OR group as a whole to match.
  """
  OR: [WhereCallForProposals!]

  """
  A nested call for proposals filter that must not match in order for the NOT
  itself to match.
  """
  NOT: WhereCallForProposals

  "Matches the call for propsals id."
  id: WhereOrderCallForProposalsId

  "Matches the call for proposals type."
  type: WhereEqCallForProposalsType

  "Matches the call for proposals semester."
  semester: WhereOrderSemester

  "Matches the active period start."
  activeStart: WhereOrderDate

  "Matches the active period end."
  activeEnd: WhereOrderDate

  "Matches whether the call is still open for some partner."
  isOpen: WhereBoolean

  "Matches whether non-partner PIs may participate."
  allowsNonPartnerPi: WhereBoolean
}

"""
Attachment filter options. All specified items must match.
"""
input WhereAttachment {
  """
  A list of nested attachment filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereAttachment!]

  """
  A list of nested attachment filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereAttachment!]

  """
  A nested attachment filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereAttachment

  """
  Matches the attachment ID.
  """
  id: WhereOrderAttachmentId

  """
  Matches the attachment file name.
  """
  fileName: WhereString

  """
  Matches the description.
  """
  description: WhereOptionString

  """
  Matches the attachment type
  """
  attachmentType: WhereAttachmentType

  """
  Matches whether the attachment has been checked or not
  """
  checked: Boolean

  """
  Matches the program containing the attachment.
  """
  program: WhereProgram
}

"""
Filters on equality of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'EQ: FINDER'

"""
input WhereAttachmentType {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: AttachmentType

  """
  Matches if the property is not the supplied value.
  """
  NEQ: AttachmentType

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [AttachmentType!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [AttachmentType!]
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.

"""
input WhereOrderAttachmentId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: AttachmentId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: AttachmentId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [AttachmentId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [AttachmentId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: AttachmentId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: AttachmentId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: AttachmentId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: AttachmentId
}

"Dataset filter options.  All specified items must match."
input WhereDataset {

  """
  A list of nested dataset filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereDataset!]

  """
  A list of nested dataset filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereDataset!]

  "A nested dataset filter that must not match in order for the NOT itself to match."
  NOT: WhereDataset

  "Matches indicated dataset(s)."
  id: WhereOrderDatasetId

  "Matches the dataset reference, if any."
  reference: WhereDatasetReference

  "Matches all datasets associated with the observation."
  observation: WhereObservation

  "Matches all datasets associated with the step."
  stepId: WhereEqStepId

  "Matches the particular dataset index within the step."
  index: WhereOrderPosInt

  "Matches the dataset file name."
  filename: WhereString

  "Matches the dataset QA state."
  qaState: WhereOptionEqQaState

  "Matches the dataset comment."
  comment: WhereOptionString
}

input WhereDatasetReference {

  "Matches if the dataset reference is not defined."
  IS_NULL: Boolean

  "Matches the dataset reference label."
  label: WhereString

  "Matches the observation reference."
  observation: WhereObservationReference

  "Matches the step index."
  stepIndex: WhereOrderPosInt

  "Matches the exposure index."
  exposureIndex: WhereOrderPosInt

}

"""
Filters on equality (or not) of the call for proposals type.  All supplied
criteria must match, but usually only one is selected.
"""
input WhereEqCallForProposalsType {

  """
  Matches if the call for proposals type is exactly the supplied value.
  """
  EQ: CallForProposalsType

  """
  Matches if the call for proposals type is not the supplied value.
  """
  NEQ: CallForProposalsType

  """
  Matches if the call for proposals type is any of the supplied options.
  """
  IN: [CallForProposalsType!]

  """
  Matches if the call for proposals type is none of the supplied values.
  """
  NIN: [CallForProposalsType!]

}

"""
Filters on equality (or not) of the user educational status and the supplied
criteria. All supplied criteria must match, but usually only one is selected.
"""
input WhereOptionEqEducationalStatus {
  """
  When `true`, matches if the QaState is not defined. When `false` matches if the QaState is defined.
  """
  IS_NULL: Boolean

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: EducationalStatus

  """
  Matches if the property is not the supplied value.
  """
  NEQ: EducationalStatus

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [EducationalStatus!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [EducationalStatus!]
}

input WhereEqExecutionEventType {

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ExecutionEventType

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ExecutionEventType

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ExecutionEventType!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ExecutionEventType!]

}

"""
Filters on equality (or not) of the user reported geender and the supplied
criteria. All supplied criteria must match, but usually only one is selected.
"""
input WhereOptionEqGender {
  """
  When `true`, matches if the QaState is not defined. When `false` matches if the QaState is defined.
  """
  IS_NULL: Boolean

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: Gender

  """
  Matches if the property is not the supplied value.
  """
  NEQ: Gender

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [Gender!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [Gender!]
}

"""
Filters on equality (or not) of the property value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "Foo"' will match when the property value is "FOO".
"""
input WhereEqPartner {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: Partner

  """
  Matches if the property is not the supplied value.
  """
  NEQ: Partner

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [Partner!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [Partner!]
}

"""
Filters on equality (or not) of the partner link type. All supplied criteria
must match, but usually only one is selected.
"""
input WhereEqPartnerLinkType {
  """
  Matches if the partner link type is exactly the supplied value.
  """
  EQ: PartnerLinkType

  """
  Matches if the partner link type is not the supplied value.
  """
  NEQ: PartnerLinkType

  """
  Matches if the partner link type is any of the supplied options.
  """
  IN: [PartnerLinkType!]

  """
  Matches if the partner link type is none of the supplied values.
  """
  NIN: [PartnerLinkType!]
}

"""
Filters on equality (or not) of the program user role type and the supplied
criteria. All supplied criteria must match, but usually only one is selected.
"""
input WhereEqProgramUserRole {

  """
  Matches if the role is exactly the supplied value.
  """
  EQ: ProgramUserRole

  """
  Matches if the role is not the supplied value.
  """
  NEQ: ProgramUserRole

  """
  Matches if the role is any of the supplied options.
  """
  IN: [ProgramUserRole!]

  """
  Matches if the role is none of the supplied values.
  """
  NIN: [ProgramUserRole!]

}

"""
Filters on equality (or not) of the program type and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "CALIBRATION"' will match when the type is "CALIBRATION".
"""
input WhereEqProgramType {
  """
  Matches if the program type is exactly the supplied value.
  """
  EQ: ProgramType

  """
  Matches if the program type is not the supplied value.
  """
  NEQ: ProgramType

  """
  Matches if the program type is any of the supplied options.
  """
  IN: [ProgramType!]

  """
  Matches if the program type is none of the supplied values.
  """
  NIN: [ProgramType!]
}

"""
Filters on equality of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'EQ: "SUBMITTED'
"""
input WhereEqProposalStatus {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ProposalStatus

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ProposalStatus

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ProposalStatus!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ProposalStatus!]
}

"""
Filters on equality (or not) of the site property. All supplied criteria must
match, but usually only one is selected.
"""
input WhereEqSite {
  """
  Matches if the site is exactly the supplied value.
  """
  EQ: Site

  """
  Matches if the site is not the supplied value.
  """
  NEQ: Site

  """
  Matches if the site is any of the supplied options.
  """
  IN: [Site!]

  """
  Matches if the site is none of the supplied values.
  """
  NIN: [Site!]
}

"""
Filters on equality (or not) of the property value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "Foo"' will match when the property value is "FOO".
"""
input WhereEqStepId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: StepId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: StepId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [StepId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [StepId!]
}

"""
Filters on equality (or not) of the property value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "Foo"' will match when the property value is "FOO".

"""
input WhereEqToOActivation {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ToOActivation

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ToOActivation

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ToOActivation!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ToOActivation!]
}

"""
Filters on equality (or not) of the user type value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.
"""
input WhereEqUserType {

  """
  Matches if the user type is exactly the supplied value.
  """
  EQ: UserType

  """
  Matches if the user type is not the supplied value.
  """
  NEQ: UserType

  """
  Matches if the user type is any of the supplied options.
  """
  IN: [UserType!]

  """
  Matches if the user type is none of the supplied values.
  """
  NIN: [UserType!]

}

"""
Filters on equality (or not) of the property value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "Foo"' will match when the property value is "FOO".

"""
input WhereEqVisitId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: VisitId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: VisitId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [VisitId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [VisitId!]
}

"""
ExecutionEvent filter options.
"""
input WhereExecutionEvent {
  """
  A list of nested execution event filters that all must match in order for the
  AND group as a whole to match.
  """
  AND: [WhereExecutionEvent!]

  """
  A list of nested execution event filters where any one match causes the
  entire OR group as a whole to match.
  """
  OR: [WhereExecutionEvent!]

  """
  A nested execution event filter that must not match in order for the NOT
  itself to match.
  """
  NOT: WhereExecutionEvent

  "Matches on the execution event id"
  id: WhereOrderExecutionEventId

  "Matches on the visit id"
  visitId: WhereEqVisitId

  "Matches on observation id"
  observationId: WhereOrderObservationId

  "Matches on event reception time"
  received: WhereOrderTimestamp

  "Matches on execution event type"
  eventType: WhereEqExecutionEventType

  "Matches the slew stage, for slew events."
  slewStage: WhereOrderSlewStage

  "Matches the sequence command type, for sequence events."
  sequenceCommand: WhereOrderSequenceCommand

  "Matches on the step id, for step and dataset events."
  stepId: WhereEqStepId

  "Matches on the step stage, for step events."
  stepStage: WhereOrderStepStage

  "Matches on the dataset id, for dataset events."
  datasetId: WhereOrderDatasetId

  "Matches on the dataset stage, for dataset events."
  datasetStage: WhereOrderDatasetStage

}

"""
Observation filter options.  All specified items must match.
"""
input WhereObservation {
  """
  A list of nested observation filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereObservation!]

  """
  A list of nested observation filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereObservation!]

  """
  A nested observation filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereObservation

  """
  Matches the observation id.
  """
  id: WhereOrderObservationId

  """
  Matches the observation reference, if any.
  """
  reference: WhereObservationReference

  """
  Matches the associated program.
  """
  program: WhereProgram

  """
  Matches the subtitle of the observation.
  """
  subtitle: WhereOptionString

  """
  Matches the observation science band.
  """
  scienceBand: WhereOptionOrderScienceBand

}

"""
Configuration request filter options.  All specified items must match.
"""
input WhereConfigurationRequest {

  """
  A list of nested filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereConfigurationRequest!]

  """
  A list of nested filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereConfigurationRequest!]

  """
  A nested filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereConfigurationRequest

  """
  Matches the configuration request id.
  """
  id: WhereOrderConfigurationRequestId

  """
  Matches the associated program.
  """
  program: WhereProgram

  """
  Matches the configuration request status.
  """
  status: WhereOrderConfigurationRequestStatus

}

input WhereObservationReference {

  "Matches if the observation reference is not defined."
  IS_NULL: Boolean

  "Matches the observation reference label."
  label: WhereString

  "Matches the program reference."
  program: WhereProgramReference

  "Matches the observation index."
  index: WhereOrderPosInt

}

input WhereGroup {

  """
  A list of nested group filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereGroup!]

  """
  A list of nested group filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereGroup!]

  """
  A nested group filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereGroup

  id: WhereOrderGroupId

  name: WhereOptionString

  description: WhereOptionString

}

input WhereOrderGroupId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: GroupId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: GroupId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [GroupId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [GroupId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: GroupId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: GroupId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: GroupId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: GroupId
}

input WhereEqFocalPlane {

  """
  Matches if the focal plane option is exactly the supplied value.
  """
  EQ: FocalPlane

  """
  Matches if the focal plane option is not the supplied value.
  """
  NEQ: FocalPlane

  """
  Matches if the focal plane option is any of the supplied values.
  """
  IN: [FocalPlane!]

  """
  Matches if the focal plane option is none of the supplied values.
  """
  NIN: [FocalPlane!]
}

"""
Filters on equality (or not) of the instrument and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "GMOS_SOUTH"' will match when the property value is "GMOS_SOUTH".
Defining, `EQ`, `NEQ` etc. implies `IS_NULL` is `false`.
"""
input WhereEqInstrument {

  """
  Matches if the instrument is exactly the supplied value.
  """
  EQ: Instrument

  """
  Matches if the instrument is not the supplied value.
  """
  NEQ: Instrument

  """
  Matches if the instrument is any of the supplied options.
  """
  IN: [Instrument!]

  """
  Matches if the instrument is none of the supplied values.
  """
  NIN: [Instrument!]
}

"""
Filters on equality (or not) of the property value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "Foo"' will match when the property value is "FOO".  Defining, `EQ`,
`NEQ` etc. implies `IS_NULL` is `false`.
"""
input WhereOptionEqCalibrationRole {
  """
  When `true`, matches if the QaState is not defined. When `false` matches if the QaState is defined.
  """
  IS_NULL: Boolean

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: CalibrationRole

  """
  Matches if the property is not the supplied value.
  """
  NEQ: CalibrationRole

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [CalibrationRole!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [CalibrationRole!]
}

"""
Filters on equality (or not) of the (optional) partner. All supplied criteria
must match, but usually only one is selected.
"""
input WhereOptionEqPartner {

  """
  When `true`, matches if the partner is not defined. When `false` matches if
  the partner is defined.
  """
  IS_NULL: Boolean

  """
  Matches if the partrner is exactly the supplied value.
  """
  EQ: Partner

  """
  Matches if the partner is not the supplied value.
  """
  NEQ: Partner

  """
  Matches if the partner is any of the supplied options.
  """
  IN: [Partner!]

  """
  Matches if the partner is none of the supplied values.
  """
  NIN: [Partner!]

}

"""
Filters on equality (or not) of the property value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "Foo"' will match when the property value is "FOO".  Defining, `EQ`,
`NEQ` etc. implies `IS_NULL` is `false`.
"""
input WhereOptionEqQaState {
  """
  When `true`, matches if the QaState is not defined. When `false` matches if the QaState is defined.
  """
  IS_NULL: Boolean

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: DatasetQaState

  """
  Matches if the property is not the supplied value.
  """
  NEQ: DatasetQaState

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [DatasetQaState!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [DatasetQaState!]
}

"""
Filters on equality (or not) of the science subtype and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "QUEUE"' will match when the property value is "QUEUE".
Defining, `EQ`, `NEQ` etc. implies `IS_NULL` is `false`.
"""
input WhereEqScienceSubtype {

  """
  Matches if the subtype is exactly the supplied value.
  """
  EQ: ScienceSubtype

  """
  Matches if the subtype is not the supplied value.
  """
  NEQ: ScienceSubtype

  """
  Matches if the subtype is any of the supplied options.
  """
  IN: [ScienceSubtype!]

  """
  Matches if the subtype is none of the supplied values.
  """
  NIN: [ScienceSubtype!]
}

"""
Filters on equality (or not) of the SpectroscopyCapabilities property. All
supplied criteria must match, but usually only one is selected.
"""
input WhereOptionEqSpectroscopyCapabilities {

  """
  When `true`, matches if the spectroscopy capability value is not defined.
  """
  IS_NULL: Boolean

  """
  Matches if the spectroscopy capability is the supplied value.
  """
  EQ: SpectroscopyCapabilities

  """
  Matches if the spectroscopy capability is anything other than the supplied
  value.
  """
  NEQ: SpectroscopyCapabilities

  """
  Matches if the spectroscopy capability is any one of the supplied values.
  """
  IN: [SpectroscopyCapabilities!]

  """
  Matches if the spectroscopy capability is not any one of the supplied values.
  """
  NIN: [SpectroscopyCapabilities!]

}

"""
Filters on equality (or not) of the property value and the supplied criteria.
All supplied criteria must match, but usually only one is selected.  E.g.
'EQ = "Foo"' will match when the property value is "FOO".  Defining, `EQ`,
`NEQ` etc. implies `IS_NULL` is `false`.

"""
input WhereOptionEqTacCategory {
  """
  When `true`, matches if the TacCategory is not defined. When `false` matches if the TacCategory is defined.
  """
  IS_NULL: Boolean

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: TacCategory

  """
  Matches if the property is not the supplied value.
  """
  NEQ: TacCategory

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [TacCategory!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [TacCategory!]
}

"""
String matching options.
"""
input WhereOptionString {
  """
  When `true` the string must not be defined.  When `false` the string must be defined.
  """
  IS_NULL: Boolean
  EQ: NonEmptyString
  NEQ: NonEmptyString
  IN: [NonEmptyString!]
  NIN: [NonEmptyString!]

  """
  Performs string matching with wildcard patterns.  The entire string must be matched.  Use % to match a sequence of any characters and _ to match any single character.
  """
  LIKE: NonEmptyString

  """
  Performs string matching with wildcard patterns.  The entire string must not match.  Use % to match a sequence of any characters and _ to match any single character.
  """
  NLIKE: NonEmptyString

  """
  Set to `true` (the default) for case sensitive matches, `false` to ignore case.
  """
  MATCH_CASE: Boolean = true
}

"""
Filters on equality or order comparisons of BigDecimal properties.  All supplied
criteria must match, but usually only one is selected.
"""
input WhereOrderBigDecimal {

  """
  Matches if the BigDecimal is exactly the supplied value.
  """
  EQ: BigDecimal

  """
  Matches if the BigDecimal is not the supplied value.
  """
  NEQ: BigDecimal

  """
  Matches if the BigDecimal is any of the supplied options.
  """
  IN: [BigDecimal!]

  """
  Matches if the BigDecimal is none of the supplied values.
  """
  NIN: [BigDecimal!]

  """
  Matches if the BigDecimal is ordered after (>) the supplied value.
  """
  GT: BigDecimal

  """
  Matches if the BigDecimal is ordered before (<) the supplied value.
  """
  LT: BigDecimal

  """
  Matches if the BigDecimal is ordered after or equal (>=) the supplied value.
  """
  GTE: BigDecimal

  """
  Matches if the BigDecimal is ordered before or equal (<=) the supplied value.
  """
  LTE: BigDecimal
}

"""
Filters on equality or order comparisons of call for proposals ids.  All
supplied criteria must match, but usually only one is selected.
"""
input WhereOrderCallForProposalsId {

  """
  Matches if the id is exactly the supplied value.
  """
  EQ: CallForProposalsId

  """
  Matches if the id is not the supplied value.
  """
  NEQ: CallForProposalsId

  """
  Matches if the id is any of the supplied options.
  """
  IN: [CallForProposalsId!]

  """
  Matches if the id is none of the supplied options.
  """
  NIN: [CallForProposalsId!]

  """
  Matches if the id is ordered after (>) the supplied value.
  """
  GT: CallForProposalsId

  """
  Matches if the id is ordered before (<) the supplied value.
  """
  LT: CallForProposalsId

  """
  Matches if the id is ordered after or equal (>=) the supplied value.
  """
  GTE: CallForProposalsId

  """
  Matches if the id is ordered before or equal (<=) the supplied value.
  """
  LTE: CallForProposalsId

}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.
"""
input WhereOrderDatasetId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: DatasetId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: DatasetId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [DatasetId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [DatasetId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: DatasetId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: DatasetId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: DatasetId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: DatasetId
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.

"""
input WhereOrderDatasetStage {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: DatasetStage

  """
  Matches if the property is not the supplied value.
  """
  NEQ: DatasetStage

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [DatasetStage!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [DatasetStage!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: DatasetStage

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: DatasetStage

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: DatasetStage

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: DatasetStage
}

"""
Filters on equality or order comparisons of the Date property.  All supplied
criteria must match, but usually only one is selected.  Dates are specified
in ISO 8601 format (e.g., YYYY-MM-DD).
"""
input WhereOrderDate {
  """
  Matches if the date is exactly the supplied value.
  """
  EQ: Date

  """
  Matches if the date is not the supplied value.
  """
  NEQ: Date

  """
  Matches if the date value is any of the supplied options.
  """
  IN: [Date!]

  """
  Matches if the date value is none of the supplied values.
  """
  NIN: [Date!]

  """
  Matches if the date is ordered after (>) the supplied value.
  """
  GT: Date

  """
  Matches if the date is ordered before (<) the supplied value.
  """
  LT: Date

  """
  Matches if the date is ordered after or equal (>=) the supplied value.
  """
  GTE: Date

  """
  Matches if the date is ordered before or equal (<=) the supplied value.
  """
  LTE: Date
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.

"""
input WhereOrderExecutionEventId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ExecutionEventId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ExecutionEventId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ExecutionEventId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ExecutionEventId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: ExecutionEventId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: ExecutionEventId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: ExecutionEventId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: ExecutionEventId
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.
"""
input WhereOrderTimestamp {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: Timestamp

  """
  Matches if the property is not the supplied value.
  """
  NEQ: Timestamp

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [Timestamp!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [Timestamp!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: Timestamp

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: Timestamp

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: Timestamp

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: Timestamp
}

"""
Filters on equality or order comparisons of the integer property.  All supplied
criteria must match, but usually only one is selected.
"""
input WhereOrderInt {
  """
  Matches if the integer is exactly the supplied value.
  """
  EQ: Int

  """
  Matches if the integer is not the supplied value.
  """
  NEQ: Int

  """
  Matches if the integer is any of the supplied options.
  """
  IN: [Int!]

  """
  Matches if the integer is none of the supplied values.
  """
  NIN: [Int!]

  """
  Matches if the integer is ordered after (>) the supplied value.
  """
  GT: Int

  """
  Matches if the integer is ordered before (<) the supplied value.
  """
  LT: Int

  """
  Matches if the integer is ordered after or equal (>=) the supplied value.
  """
  GTE: Int

  """
  Matches if the integer is ordered before or equal (<=) the supplied value.
  """
  LTE: Int
}

"""
Filters on equality or order comparisons of long property.  All supplied
criteria must match, but usually only one is selected.
"""
input WhereOrderLong {

  """
  Matches if the Long is exactly the supplied value.
  """
  EQ: Long

  """
  Matches if the Long is not the supplied value.
  """
  NEQ: Long

  """
  Matches if the Long is any of the supplied options.
  """
  IN: [Long!]

  """
  Matches if the Long is none of the supplied values.
  """
  NIN: [Long!]

  """
  Matches if the Long is ordered after (>) the supplied value.
  """
  GT: Long

  """
  Matches if the Long is ordered before (<) the supplied value.
  """
  LT: Long

  """
  Matches if the Long is ordered after or equal (>=) the supplied value.
  """
  GTE: Long

  """
  Matches if the Long is ordered before or equal (<=) the supplied value.
  """
  LTE: Long
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.

"""
input WhereOrderObservationId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ObservationId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ObservationId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ObservationId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ObservationId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: ObservationId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: ObservationId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: ObservationId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: ObservationId
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.
"""
input WhereOrderConfigurationRequestId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ConfigurationRequestId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ConfigurationRequestId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ConfigurationRequestId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ConfigurationRequestId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: ConfigurationRequestId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: ConfigurationRequestId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: ConfigurationRequestId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: ConfigurationRequestId
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.
"""
input WhereOrderConfigurationRequestStatus {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ConfigurationRequestStatus

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ConfigurationRequestStatus

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ConfigurationRequestStatus!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ConfigurationRequestStatus!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: ConfigurationRequestStatus

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: ConfigurationRequestStatus

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: ConfigurationRequestStatus

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: ConfigurationRequestStatus
}


"""
Filters on equality or order comparisons of PosBigDecimal properties.  All
supplied criteria must match, but usually only one is selected.
"""
input WhereOrderPosBigDecimal {

  """
  Matches if the PosBigDecimal is exactly the supplied value.
  """
  EQ: PosBigDecimal

  """
  Matches if the PosBigDecimal is not the supplied value.
  """
  NEQ: PosBigDecimal

  """
  Matches if the PosBigDecimal is any of the supplied options.
  """
  IN: [PosBigDecimal!]

  """
  Matches if the PosBigDecimal is none of the supplied values.
  """
  NIN: [PosBigDecimal!]

  """
  Matches if the PosBigDecimal is ordered after (>) the supplied value.
  """
  GT: PosBigDecimal

  """
  Matches if the PosBigDecimal is ordered before (<) the supplied value.
  """
  LT: PosBigDecimal

  """
  Matches if the PosBigDecimal is ordered after or equal (>=) the supplied value.
  """
  GTE: PosBigDecimal

  """
  Matches if the PosBigDecimal is ordered before or equal (<=) the supplied value.
  """
  LTE: PosBigDecimal
}

"""
Filters on equality or order comparisons of the PosInt property.  All supplied
criteria must match, but usually only one is selected.
"""
input WhereOrderPosInt {
  """
  Matches if the PosInt is exactly the supplied value.
  """
  EQ: PosInt

  """
  Matches if the PosInt is not the supplied value.
  """
  NEQ: PosInt

  """
  Matches if the PosInt is any of the supplied options.
  """
  IN: [PosInt!]

  """
  Matches if the PosInt is none of the supplied values.
  """
  NIN: [PosInt!]

  """
  Matches if the PosInt is ordered after (>) the supplied value.
  """
  GT: PosInt

  """
  Matches if the PosInt is ordered before (<) the supplied value.
  """
  LT: PosInt

  """
  Matches if the PosInt is ordered after or equal (>=) the supplied value.
  """
  GTE: PosInt

  """
  Matches if the PosInt is ordered before or equal (<=) the supplied value.
  """
  LTE: PosInt
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.
"""
input WhereOrderProgramId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: ProgramId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: ProgramId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [ProgramId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [ProgramId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: ProgramId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: ProgramId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: ProgramId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: ProgramId
}

input WhereOrderUserId {

  """
  Matches if the user id is exactly the supplied value.
  """
  EQ: UserId

  """
  Matches if the user id is not the supplied value.
  """
  NEQ: UserId

  """
  Matches if the user id is any of the supplied options.
  """
  IN: [UserId!]

  """
  Matches if the user id is none of the supplied values.
  """
  NIN: [UserId!]

  """
  Matches if the user id is ordered after (>) the supplied value.
  """
  GT: UserId

  """
  Matches if the user id is ordered before (<) the supplied value.
  """
  LT: UserId

  """
  Matches if the user id is ordered after or equal (>=) the supplied value.
  """
  GTE: UserId

  """
  Matches if the user id is ordered before or equal (<=) the supplied value.
  """
  LTE: UserId

}

input WhereProposalReference {

  "Matches if the proposal reference is not defined."
  IS_NULL: Boolean

  "Matches the proposal reference label."
  label: WhereString

  "Matches the semester in the proposal reference."
  semester: WhereOrderSemester

  "Matches the index in the proposal reference."
  semesterIndex: WhereOrderPosInt

}

"""
Filters on equality or order comparisons of science bands.  All supplied
criteria must match, but usually only one is selected.
"""
input WhereOptionOrderScienceBand {

  """
  When `true`, matches if the science band is not defined. When `false` matches
  if the science band is defined.
  """
  IS_NULL: Boolean

  """
  Matches if the science band is exactly the supplied value.
  """
  EQ: ScienceBand

  """
  Matches if the science band is not the supplied value.
  """
  NEQ: ScienceBand

  """
  Matches if the science band is any of the supplied options.
  """
  IN: [ScienceBand!]

  """
  Matches if the science band is none of the supplied values.
  """
  NIN: [ScienceBand!]

  """
  Matches if the science band is ordered after (>) the supplied value.
  """
  GT: ScienceBand

  """
  Matches if the science band is ordered before (<) the supplied value.
  """
  LT: ScienceBand

  """
  Matches if the science band is ordered after or equal (>=) the supplied value.
  """
  GTE: ScienceBand

  """
  Matches if the science band is ordered before or equal (<=) the supplied value.
  """
  LTE: ScienceBand
}

"""
Filters on equality or order comparisons of Semester.  All supplied
criteria must match, but usually only one is selected.  E.g.,
'GT = "2024A"' will match when the value is "2024B" or later.
"""
input WhereOrderSemester {

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: Semester

  """
  Matches if the property is not the supplied value.
  """
  NEQ: Semester

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [Semester!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [Semester!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: Semester

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: Semester

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: Semester

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: Semester
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.
"""
input WhereOrderSequenceCommand {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: SequenceCommand

  """
  Matches if the property is not the supplied value.
  """
  NEQ: SequenceCommand

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [SequenceCommand!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [SequenceCommand!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: SequenceCommand

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: SequenceCommand

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: SequenceCommand

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: SequenceCommand
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.

"""
input WhereOrderSequenceType {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: SequenceType

  """
  Matches if the property is not the supplied value.
  """
  NEQ: SequenceType

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [SequenceType!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [SequenceType!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: SequenceType

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: SequenceType

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: SequenceType

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: SequenceType
}

"""
Filters on equality or order comparisons of the SlewStage.  All supplied
criteria must match, but usually only one is selected.
"""
input WhereOrderSlewStage {

  """
  Matches if the property is exactly the supplied value.
  """
  EQ: SlewStage

  """
  Matches if the property is not the supplied value.
  """
  NEQ: SlewStage

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [SlewStage!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [SlewStage!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: SlewStage

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: SlewStage

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: SlewStage

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: SlewStage
}


"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.

"""
input WhereOrderStepStage {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: StepStage

  """
  Matches if the property is not the supplied value.
  """
  NEQ: StepStage

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [StepStage!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [StepStage!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: StepStage

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: StepStage

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: StepStage

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: StepStage
}

"""
Filters on equality or order comparisons of the property.  All supplied
criteria must match, but usually only one is selected.  E.g., 'GT = 2'
for an integer property will match when the value is 3 or more.

"""
input WhereOrderTargetId {
  """
  Matches if the property is exactly the supplied value.
  """
  EQ: TargetId

  """
  Matches if the property is not the supplied value.
  """
  NEQ: TargetId

  """
  Matches if the property value is any of the supplied options.
  """
  IN: [TargetId!]

  """
  Matches if the property value is none of the supplied values.
  """
  NIN: [TargetId!]

  """
  Matches if the property is ordered after (>) the supplied value.
  """
  GT: TargetId

  """
  Matches if the property is ordered before (<) the supplied value.
  """
  LT: TargetId

  """
  Matches if the property is ordered after or equal (>=) the supplied value.
  """
  GTE: TargetId

  """
  Matches if the property is ordered before or equal (<=) the supplied value.
  """
  LTE: TargetId
}

"""
Partner link filter options.  All specified items much match.
"""
input WherePartnerLink {

  """
  Matches on equality of the link type.
  """
  linkType: WhereEqPartnerLinkType

  """
  Matches on the partner itself, if applicable.  Only `HAS_PARTNER` link types
  will have a partner.  For other link types it will be `null`.
  """
  partner: WhereOptionEqPartner

}

"""
Program filter options.  All specified items must match.
"""
input WhereProgram {
  """
  A list of nested program filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereProgram!]

  """
  A list of nested program filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereProgram!]

  """
  A nested program filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereProgram

  """
  Matches the program ID.
  """
  id: WhereOrderProgramId

  """
  Matches the program name.
  """
  name: WhereOptionString

  """
  Mathces the program type.
  """
  type: WhereEqProgramType

  """
  Matches the program reference (if any).
  """
  reference: WhereProgramReference

  """
  Matches the PI.
  """
  pi: WhereProgramUser

  """
  Matches the proposalStatus.
  """
  proposalStatus: WhereEqProposalStatus

  """
  Matches the proposal.
  """
  proposal: WhereProposal

  """
  Matches the calibration role.
  """
  calibrationRole: WhereOptionEqCalibrationRole
}

input WhereProgramReference {

  "Matches if the program reference is not defined."
  IS_NULL: Boolean

  "Matches the program reference label."
  label: WhereString

  "Matches the semester in the proposal reference, if any."
  semester: WhereOrderSemester

  "Matches the index in the program reference, if any."
  semesterIndex: WhereOrderPosInt

  "Matches the instrument in the program reference, if any."
  instrument: WhereEqInstrument

  "Matches the (library) description in the program reference, if any."
  description: WhereString

  "Matches the science subtype in the program reference, if any."
  scienceSubtype: WhereEqScienceSubtype
}

"""
Program user options.  All specified items must match.
"""
input WhereProgramUser {

  """
  A list of nested program user filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereProgramUser!]

  """
  A list of nested program user filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereProgramUser!]

  """
  A nested program user filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereProgramUser

  """
  Matches the program.
  """
  program: WhereProgram

  """
  Matches the user.
  """
  user: WhereUser

  """
  Matches the role.
  """
  role: WhereEqProgramUserRole

  """
  Matches the partner.
  """
  partnerLink: WherePartnerLink

  """
  Matches the fallback profile.
  """
  fallbackProfile: WhereUserProfile

  """
  Matches the educational status.
  """
  educationalStatus: WhereOptionEqEducationalStatus

  """
  Matches the thesis flag.
  """
  thesis: WhereOptionBoolean

  """
  Matches the gender status.
  """
  gender: WhereOptionEqGender
}

"""
Proposal filter options.  All specified items must match.
"""
input WhereProposal {

  """
  When `true`, matches if the proposal is not defined. When `false` matches if the proposal is defined.
  """
  IS_NULL: Boolean

  """
  A list of nested proposal filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereProposal!]

  """
  A list of nested proposal filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereProposal!]

  """
  A nested proposal filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereProposal

  """
  Matches the proposal title.
  """
  title: WhereOptionString

  """
  Matches on the proposal reference (if any).
  """
  reference: WhereProposalReference

#  """
#  Matches the proposal TAC category.
#  """
#  category: WhereOptionEqTacCategory
#
#  """
#  Matches the Target of Opportunity setting.
#  """
#  toOActivation: WhereEqToOActivation
#
#  """
#  Matches the proposal abstract.
#  """
#  abstract: WhereOptionString
#
#  """
#  Matches proposal partners.
#  """
#  partners: WhereProposalPartners
}

"""
Proposal partner entry filter options. The set of partners is scanned for a matching partner and percentage entry.
"""
input WhereProposalPartnerEntry {
  """
  A list of nested partner entry filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereProposalPartnerEntry!]

  """
  A list of nested partner entry filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereProposalPartnerEntry!]

  """
  A nested partner entry filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereProposalPartnerEntry

  """
  Matches on partner equality
  """
  partner: WhereEqPartner

  """
  Matches on partner percentage
  """
  percent: WhereOrderInt
}

"""
Proposal partners matching.  Use `MATCH` for detailed matching options, `EQ` to just match against a partners list, and/or `isJoint` for checking joint vs individual proposals
"""
input WhereProposalPartners {
  """
  Detailed partner matching.  Use EQ instead of a simple exact match.
  """
  MATCH: WhereProposalPartnerEntry

  """
  A simple exact match for the supplied partners. Use `MATCH` instead for more advanced options.
  """
  EQ: [Partner!]

  """
  Matching based on whether the proposal is a joint (i.e., multi-partner) proposal.
  """
  isJoint: Boolean
}

"""
Spectroscopy instrument configuration option matcher.  Configure with the
properties of interest and pass it to the 'spectroscopyConfigOptions' query
to find the corresponding configuration options.
"""
input WhereSpectroscopyConfigOption {

  AND: [WhereSpectroscopyConfigOption!]

  OR: [WhereSpectroscopyConfigOption!]

  NOT: WhereSpectroscopyConfigOption

  adaptiveOptics: WhereBoolean

  capability: WhereOptionEqSpectroscopyCapabilities

  focalPlane: WhereEqFocalPlane

  instrument: WhereEqInstrument

  resolution: WhereOrderPosInt

  site: WhereEqSite

  slitLength: WhereAngle

  slitWidth:  WhereAngle

  """
  Matches configuration options that support the provided wavelength. In other
  words, those for which the given wavelength falls between the min and max
  limits of the configuration.
  """
  rangeIncludes: WavelengthInput

  wavelengthOptimal:  WhereWavelength

  wavelengthCoverage: WhereWavelength

}

"""
String matching options.
"""
input WhereString {
  EQ: NonEmptyString
  NEQ: NonEmptyString
  IN: [NonEmptyString!]
  NIN: [NonEmptyString!]

  """
  Performs string matching with wildcard patterns.  The entire string must be
  matched.  Use % to match a sequence of any characters and _ to match any
  single character.
  """
  LIKE: NonEmptyString

  """
  Performs string matching with wildcard patterns.  The entire string must not
  match.  Use % to match a sequence of any characters and _ to match any single
  character.
  """
  NLIKE: NonEmptyString

  """
  Set to `true` (the default) for case sensitive matches, `false` to ignore case.
  """
  MATCH_CASE: Boolean = true
}

"""
Target filter options.  All specified items must match.
"""
input WhereTarget {
  """
  A list of nested target filters that all must match in order for the AND group as a whole to match.
  """
  AND: [WhereTarget!]

  """
  A list of nested target filters where any one match causes the entire OR group as a whole to match.
  """
  OR: [WhereTarget!]

  """
  A nested target filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereTarget

  """
  Matches the target id.
  """
  id: WhereOrderTargetId

  """
  Matches the associated program.
  """
  program: WhereProgram

  """
  Matches the target name.
  """
  name: WhereString

  """
  Matches the calibration role.
  """
  calibrationRole: WhereOptionEqCalibrationRole
}

"""
User filter options.  All specified items must match.
"""
input WhereUser {

  """
  A list of nested user filters that all must match in order for the AND group
  as a whole to match.
  """
  AND: [WhereUser!]

  """
  A list of nested user filters that all must match in order for the OR group
  as a whole to match.
  """
  OR: [WhereUser!]

  """
  A nested user filter that must not match in order for the NOT itself to match.
  """
  NOT: WhereUser

  "Matches the user Id."
  id: WhereOrderUserId

  "Matches the user type."
  type: WhereEqUserType

  orcidId: WhereOptionString
  profile: WhereUserProfile

}

input WhereUserProfile {
  givenName:  WhereOptionString
  creditName: WhereOptionString
  familyName: WhereOptionString
  email:      WhereOptionString
}

input WhereWavelength {

  AND: [WhereWavelength!]

  OR: [WhereWavelength!]

  NOT: WhereWavelength

  picometers: WhereOrderPosInt

  angstroms: WhereOrderPosBigDecimal

  nanometers: WhereOrderPosBigDecimal

  micrometers: WhereOrderPosBigDecimal

}

type OffsetQ {
  """
  q offset in µas
  """
  microarcseconds: Long!

  """
  q offset in mas
  """
  milliarcseconds: BigDecimal!

  """
  q offset in arcsec
  """
  arcseconds: BigDecimal!
}

"""
The `BigDecimal` scalar type represents signed fractional values with arbitrary precision.
"""
scalar BigDecimal

"""
The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long


enum ObservationWorkflowState {
  INACTIVE
  UNDEFINED
  UNAPPROVED
  DEFINED
  READY
  ONGOING
  COMPLETED
}

type ObservationWorkflow {
  state: ObservationWorkflowState!
  validTransitions: [ObservationWorkflowState!]!
  validationErrors: [ObservationValidation!]!
}

